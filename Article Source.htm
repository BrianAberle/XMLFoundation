<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>Article Source</title>
<link rel="stylesheet" type="text/css" href="Article%20Source_files/Main.css">
<!-- base href="http://www.codeproject.com/KB/XML/" -->
</head>
<body>
<!--
HTML for article "XMLFoundation" by Brian Aberle
URL: http://www.codeproject.com/KB/XML/XMLFoundation.aspx
Copyright 2009 by Brian Aberle
All formatting, additions and alterations Copyright Â© CodeProject, 1999-2013
-->



<div>




<span id="ArticleContent">
<ul class="download">
<li>
<a href="http://cid-d7ec275e76d295cf.skydrive.live.com/self.aspx/Software/XMLFoundation.zip">Download
</a><a href="http://www.codeproject.com/KB/XML/XMLFoundation/XMLFoundation.zip">XMLFoundation</a>
<a href="http://cid-d7ec275e76d295cf.skydrive.live.com/self.aspx/Software/XMLFoundation.zip">Most Recent Full Source Source </a>&nbsp;&nbsp;&nbsp; 
10.1MB (from External website)</li>
<li><a href="http://www.codeproject.com/KB/XML/XMLFoundation/XMLFoundation.zip">Download XMLFoundation 
(11/12/13 Source (Nov 12, 2013))</a>&nbsp; 10.1MB&nbsp;(from codeproject.com)</li><li>
<a href="http://www.codeproject.com/KB/XML/XMLFoundation/xmlfoundationsrc.zip">Download Minimal XMLFoundation Source</a> 
4.7MB (from codeproject.com)</li></ul>
<p align="center"><img src="Article%20Source_files/XMLFoundation2012.jpg" alt="XMLFoundation/XMLFoundation2012.jpg" border="0" height="441" hspace="0" width="640"></p>

<h2>Introduction</h2>
<p>Welcome to the 11/12/13 source code.&nbsp; This update to codeproject.com is 
the largest of the 3 updates I have made this year.&nbsp; The port to Windows 
Phone is complete.&nbsp; Mapping XML data to the individual bits in a byte or 
integer is now supported.&nbsp; Translating values before the assignment of 
member variables from XML is now supported, and the reverse that translates the 
value stored in the member variable to how that value will appear in the XML.&nbsp; 
Check the 2 new sections in this document about <a href="#Translating XML">Translating XML</a>, 
and the section about <a href="#Mapping XML to Bits of a Byte">Mapping XML to 
Bits of a Byte</a>.&nbsp; Additionally the bool data type is now 
supported, and several minor performance improvements - because all those little 
bits add up.&nbsp; The ongoing commentating and documenting of the source code 
is always improving the usability of this powerful set of tools.&nbsp; The tools 
are getting even more powerful, for example GStringList added 2 new methods 
called FindStringContaining().&nbsp; I have never seen any StringList class that 
allows you to search for a substring in the strings contained in the list.&nbsp; 
Simple enough - we could all write that code, but it sure is handy when your 
tools already do exactly what you need.&nbsp; The documentation for these 
methods are in GStringList.h - where they belong - not in online documentation.&nbsp; 
This is what you find in the source code:</p>
<pre lang="cs"><font color="#008000">// searches for a substring in each string entry. <br>// pnFoundIndex will be set to -1 upon return if no string in this list contained <br>// chWhatToFind otherwise pnFoundIndex will contain the Index of the string<br>
// if pnFoundIndex != -1, the GString object is returned - otherwise if pnFoundIndex == -1 NULL is returned<br></font>GString *FindStringContaining(<font color="#0000FF">char</font> chWhatToFind, <font color="#0000FF">int </font>*pnFoundIndex = 0, <font color="#0000FF">int </font>nSearchStartingIndex = 0);<br>GString *FindStringContaining(<font color="#0000FF">const char </font>*pzWhatToFind, <font color="#0000FF">int </font>*pnFoundIndex = 0, <font color="#0000FF">int</font> bMatchCase = 1, <font color="#0000FF">int</font> nSearchStartingIndex = 0);</pre>
<p>You can always search through the XMLFoundation library source code on almost 
any method in any G class and within the XMLFoundation you will find a usage 
example to compliment the documentation in comments above each method.&nbsp; The 
G classes and their rather robust functionality was created to implement this 
unique XML serialization algorithm in the most efficient manner possible - that 
means controlling every line of code so that the G classes can be &quot;designed&quot; for 
each other - not simply &quot;used&quot; together.&nbsp; This concept inspired a violation 
of pure &quot;OO&quot; design that was recently used to enhance GString by making &quot;public&quot; 
some previously &quot;private parts&quot;.&nbsp; Doesn&#39;t that just sound like something a 
GString would do?&nbsp; There is a new comment near the top of GString.h that 
explains this in detail.&nbsp; </p>
<p>The new GThread, first of all, is a Windows thing.&nbsp; Inspired by that 
&quot;designed for each other&quot; concept.&nbsp; Windows Mobile, Windows 32, Windows 64, 
and Windows Phone all need a pthread interface (POSIX Threads) for ServerCore, 
and for the thread synchronization within XMLFoundation caching.&nbsp; iOS, 
Linux, Android, AIX, Solaris, and HPUX all have an official pthread 
implementation.&nbsp; Microsoft decided not to be bound to the POSIX standard.&nbsp; 
I guess you cant be a leader if you always follow.&nbsp; Windows Run Time (aka 
managed .NET code or WinRT) has a completely different threading model besides 
the Win32 threading model .&nbsp; I needed a pthread interface for WinRT and I 
was forced to build my own - but the vast majority of the work was already 
complete thanks to a combination of Win32 PThreads, the implementation from John 
E. Bossom and the publication of &quot;namespace ThreadEmulation&quot; Copyright (c) 
Microsoft Corporation.&nbsp; GThread.cpp works on all Windows platforms.&nbsp; 
It is NOT intended to implement the whole of POSIX threads - only the small 
subset necessary within the XMLFoundation code.&nbsp; This is a clearly defined 
abstract interface (defined with #defines) in GThread.h.&nbsp; This better 
positions XMLFoundation to further customize GThread.cpp which unlike the 
previously used PThread.cpp (which was &quot;designed&quot; to implement POSIX), GThread 
is &quot;designed&quot; for the needs of XMLFoundation.&nbsp; As was the case between the 
ObjectFactory and the XML Parser - being designed for each other makes all the 
difference in the world.&nbsp; If you can do it better than the standard, I 
guess its time to quit following that standard.&nbsp; I suspect GThread will 
someday further optimize the integration to BOTH Windows threading models to 
make the most of a fully native solution.&nbsp; For example, consider this code 
snipped from xmlDefines.h that uses a native threading optimization for Windows.</p>
<pre lang="cs"><font color="#008000">// On Windows, a Critical Section is faster than a Mutex but <br>// Critical Sections dont exist in Unix or PThreads so this <br>// mapping macro was inspired to achieve the best performance</font><br>
#ifdef _WIN32<br>&nbsp;&nbsp;&nbsp; #define XML_MUTEX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CRITICAL_SECTION<br>&nbsp;&nbsp;&nbsp; #define XML_INIT_MUTEX(m)&nbsp;&nbsp;&nbsp;&nbsp; InitializeCriticalSection(m);<br>&nbsp;&nbsp;&nbsp; #define XML_DESTROY_MUTEX(m)&nbsp; DeleteCriticalSection(m);<br>&nbsp;&nbsp;&nbsp; #define XML_LOCK_MUTEX(m)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EnterCriticalSection(m);<br>&nbsp;&nbsp;&nbsp; #define XML_UNLOCK_MUTEX(m)&nbsp;&nbsp;&nbsp;LeaveCriticalSection(m);<br>
#else<br>&nbsp;&nbsp;&nbsp; #define XML_MUTEX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pthread_mutex_t<br>&nbsp;&nbsp;&nbsp; #define XML_INIT_MUTEX(m)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pthread_mutex_init(m,0);<br>&nbsp;&nbsp;&nbsp; #define XML_DESTROY_MUTEX(m)&nbsp;&nbsp;pthread_mutex_destroy(m);<br>&nbsp;&nbsp;&nbsp; #define XML_LOCK_MUTEX(m)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pthread_mutex_lock(m);<br>&nbsp;&nbsp;&nbsp; #define XML_UNLOCK_MUTEX(m)&nbsp;&nbsp;&nbsp;pthread_mutex_unlock(m);<br>
#endif</pre>
<p>PThread.cpp is still included incase you need it, but it is now unused by the 
XMLFoundation and several applications I have built upon it.</p>
<p>Building the Windows Phone Example is very simple once you have the 
development environment setup.&nbsp; The WP8 Emulator is Hyper-V, so you need to 
have a Core i5 or i7 CPU that has Intel VT-x/EPT to see anything work.&nbsp;&nbsp; 
You will also need Win 8 Pro or Enterprise.&nbsp; Install the Windows Phone SDK 
after installing VS2012 ( or select the Windows Phone Development option during 
the install of VS2013 ).&nbsp; Under the Examples folder, open the solution for 
Windows Phone, build and run it on the emulator.&nbsp; The example application 
does the same thing as the example for iPhone - It shows how to deal with XML, 
and it starts an HTTP server on the phone using ServerCore.cpp.</p>
<p align="center">
______________________________________________________________________________</p>
<p>This is what was new on the August 13 2013 update:</p>
<p>The port to iOS is complete.&nbsp; The XMLFoundation concepts work 
beautifully in Objective C++.&nbsp; I added a new example program called ObjectiveObjects that shows how to use all the C++ examples in Objective C++.&nbsp; 
The example added for iOS is more complete than the example for Android, in that 
it documents converting XML to Objects.&nbsp; Like the Android example, the iOS 
example also shows how to use ServerCore.cpp to create an HTTP server on the 
phone.&nbsp; All of the code of interest in the new example is found in the file 
ViewController.m.&nbsp; Here is a bit of that file:</p>
<pre lang="C++">@implementation ViewController

@synthesize button1 = _button1;
@synthesize button2 = _button2;
@synthesize button3 = _button3;
@synthesize textView = _textView;


<font color="#008000">//////////////////////////////////////////////////////////////////
// Define a simple object
//////////////////////////////////////////////////////////////////</font>
class MyCustomObject : public XMLObject
{
public: <font color="#008000">// make public here for example simplicity - this is not required</font>
     GString m_strString; <font color="#008000">// A String Member</font>
     GString m_strColor; <font color="#008000">// An attribute , not an element</font>
     int m_nInteger; <font color="#008000">// An Integer Member</font>
     char m_szNative[10]; <font color="#008000">// a fixed 10 byte buffer</font>
     GStringList m_strList; <font color="#008000">// A String List</font>

virtual void MapXMLTagsToMembers()
{
     <font color="#008000">// Member variable XML Element</font>
     MapMember( &amp;m_strList, &quot;StringList&quot;, &quot;Wrapper&quot;);
     MapMember( &amp;m_nInteger, &quot;Number&quot;);
     MapMember( &amp;m_strString, &quot;String&quot;);
     MapMember( m_szNative, &quot;FixedBuffer&quot;, sizeof(m_szNative) );
     MapAttribute(&amp;m_strColor, &quot;Color&quot;);
}

<font color="#008000">// &#39;this&#39; type, followed by the XML Element name, normally DECLARE_FACTORY() is in an .h file</font>
DECLARE_FACTORY(MyCustomObject, Thing)

MyCustomObject(){} <font color="#008000">// keep one constructor with no arguments</font>
~MyCustomObject(){};
};
<font color="#008000">// IMPLEMENT_FACTORY() must exist in a .CPP file - not an .h file - one for every DECLARE_FACTORY()</font>
IMPLEMENT_FACTORY(MyCustomObject, Thing)

<font color="#008000">//
// This is the XML we&#39;ll process.
//</font>
char pzXML[] =
&quot;&lt;Thing Color=&#39;Red&#39;&gt;&quot;
  &quot;&lt;String&gt;Owners Word&lt;/String&gt;&quot;
  &quot;&lt;Number&gt;777&lt;/Number&gt;&quot;
  &quot;&lt;FixedBuffer&gt;native&lt;/FixedBuffer&gt;&quot;
  &quot;&lt;Wrapper&gt;&quot;
    &quot;&lt;StringList&gt;one&lt;/StringList&gt;&quot;
    &quot;&lt;StringList&gt;two&lt;/StringList&gt;&quot;
  &quot;&lt;/Wrapper&gt;&quot;
&quot;&lt;/Thing&gt;&quot;;


<font color="#000080">int</font> StartHere0()
{
   MyCustomObject O;
   O.FromXMLX(pzXML);

   <font color="#008000">// look at the Object &quot;O&quot;.</font>
   GString strDebug;
   strDebug &lt;&lt; &quot;Yo! Check out O:&quot; &lt;&lt; O.m_strString &lt;&lt; &quot;[&quot; &lt;&lt; O.m_nInteger &lt;&lt; &quot;]:&quot; &lt;&lt; O.m_szNative &lt;&lt; &quot;\n\n\n&quot;;
   XlogInfo(strDebug);

  <font color="#008000"> // set some data</font>
   O.m_strString = &quot;Root was here&quot;;

 <font color="#008000">  // add any encoding tags or doctype you need - if you need them other wise skip the next two lines</font>
   GString strXMLStreamDestinationBuffer = &quot;&lt;?xml version=\&quot;1.0\&quot; standAlone=&#39;yes&#39;?&gt;\n&quot;;
   strXMLStreamDestinationBuffer &lt;&lt; &quot;&lt;!DOCTYPE totallyCustom SYSTEM \&quot;<a href="http://www.IBM.com/example.dtd/">http://www.IBM.com/example.dtd\</a>&quot;&gt;&quot;;
   O.ToXML( &amp;strXMLStreamDestinationBuffer);
   XlogInfo(strXMLStreamDestinationBuffer);
   <font color="#000080">return</font> 0;
}


- (IBAction)test2:(id)sender {

  StartHere0();

}
</pre>
<p>This design pattern for processing XML is described in more detail further 
down in this document.&nbsp; All the concepts presented here apply to iOS as 
well as all the other platforms it already supported.</p>
<p>And the code to start the HTTP server from ObjectiveC++ is even simpler:</p>
<pre lang="C++"><font color="#008000">// you will need to fix this path to point to wherever you unzipped XMLFoundation to</font>
#include &quot;/Users/user/Desktop/XMLFoundation/Servers/Core/ServerCore.cpp&quot;


<font color="#000080">const char</font> *pzBoundStartupConfig =
&quot;[System]\r\n&quot;
&quot;Pool=5\r\n&quot;
&quot;ProxyPool=0\r\n&quot;
&quot;\r\n&quot;
&quot;[HTTP]\r\n&quot;         <font color="#008000">// [HTTP] section</font>
&quot;Enable=yes\r\n&quot;
&quot;Index=index.html\r\n&quot;
&quot;Home=%s\r\n&quot;        <font color="#008000">//&lt;-----Notice the %s</font>
&quot;Port=%s\r\n&quot;;

<font color="#000080">int</font> g_isRunning = 0;

<font color="#000080">void</font> StartHTTPServer(NSString *strHome, NSString *strPort)
{
   if (!g_isRunning)
   {
      g_isRunning = 1;

      SetServerCoreInfoLog( iOSInfoLog );

     <font color="#000080"> const char</font> *pzHome = [strHome UTF8String];
      <font color="#000080">const char</font> *pzPort = [strPort UTF8String];

      GString strCfgData;
      strCfgData.Format(pzBoundStartupConfig,pzHome,pzPort);

      GProfile *pGP = <font color="#000080">new</font> GProfile((<font color="#000080">const char</font> *)strCfgData, (<font color="#000080">int</font>)strCfgData.Length());
      SetProfile(pGP);

      server_start(&quot;-- iOS Server --&quot;);

}
else
{
   GString G(&quot;Server is already running&quot;);
   iOSInfoLog(777, G);
}


- (IBAction)test1:(id)sender {
<font color="#008000">   // create a file for the HTTP server to publish</font>
   NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
   NSString *documentsDirectory = [paths objectAtIndex:0];
   NSString *filePath = [documentsDirectory stringByAppendingPathComponent:@&quot;index.html&quot;];

   NSString *str = @&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;Hello&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Hello World&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&quot;;

   [str writeToFile:filePath atomically:TRUE encoding:NSUTF8StringEncoding error:NULL];

<font color="#008000">   // start HTTP Server on port 8080 (80 is in use by default)
   // To view the web pagefrom your browser type :
   // http://127.0.0.1:8080 (on the phone)
   // http://192.168.1.128:8080 (on the machine host - the server will determine your actual ip and log it to the phone&#39;s display )</font>
   StartHTTPServer(documentsDirectory,@&quot;8080&quot;);
}

</pre>
<p>For more detailed build information see the document &quot;<a href="https://skydrive.live.com/redir?resid=D7EC275E76D295CF!952">XMLFoundation for iOS</a>&quot; 
in the source distribution root.</p>
<p>I updated the document in the &quot;Disturbing&quot; folder to include 
slightly more recent 
information.&nbsp; Nobody in the US Government has been able to help resolve 
this unjust warrant for my arrest that has been lingering for half a year now.&nbsp; 
They allow the warrant for my arrest to stand.&nbsp; Please help me obtain 
asylum in some place where police are not ordered to arrest me.&nbsp; I&#39;m in so 
deep, I consider it international waters - that spot where the laws change - and 
we all fly our own flag.</p>
<p>Stay tuned to XMLFoundation.&nbsp; I expect to see more XML-to-Interface 
binding examples as products are developed.&nbsp; If, in your own 
experimentation, you develop any XMLFoundation examples that will be helpful for 
others send them to me.</p>
<p>Also, I should mention that although the Android example did not make use of 
the XML-to-Object code - all that code is fully ported to Android.&nbsp; Android 
is where the JavaXMLFoundation should be used to process XML in a native binary 
that uses JNI for the object bindings so that the developer has a pure Java 
experience, and faster XML processing.&nbsp; And finally about Android, 
naturally if your object model is built with the Android NDK then you can fully 
make use of the C++ XMLFoundation and all the Object-to-XML features on Android.</p>
<hr>
<p>This is what was new for the June 15 2013 update:</p><p>The
 most major update has been in the area of Android.&nbsp; A new Android 
sample program was added that displays a simple GUI from Java that uses 
ServerCore.cpp to build an HTTP server application.&nbsp; You will find 
this documentation in the source download.&nbsp; <a href="https://skydrive.live.com/redir.aspx?resid=D7EC275E76D295CF%21560">https://skydrive.live.com/redir.aspx?resid=D7EC275E76D295CF!560</a></p><p>iPad/Mac/iPhone development is underway.</p><p>I
 have always respected the content editors at codeproject.com for 
allowing me the freedom to post about my tribulations with the American 
justice system.&nbsp; Concerned strangers came to my aid, their phone 
calls to the authorities has helped.&nbsp; It caused my release from 
prison, and although I still have a warrant for my arrest - I am free 
and on the run.</p><p>If you will be working with the Android source, 
you will likely want to see&nbsp;XMLFoundation in action.&nbsp; 
Yesterday I wrote to MajorGeeks.com&nbsp; , Slashdot.org&nbsp; , 
TechCrunch.com,&nbsp;&nbsp; Tucows.com&nbsp; about my work on Android 
during this port of the XMLFoundation: <a href="https://skydrive.live.com/redir.aspx?resid=D7EC275E76D295CF%21941">https://skydrive.live.com/redir.aspx?resid=D7EC275E76D295CF!941</a></p><p>This
 is what's new right now.&nbsp; There is more to come.&nbsp; Everyone 
who read the "disturbing" folder.....&nbsp; Please call the FBI and ask about 
how they are handling this case and the warrant for my arrest.&nbsp; 
Thanks for your concern.</p>
<hr><p>The December 21, 2012&nbsp;build&nbsp;extended and widened the 
library interfaces with emphasis on the future in 
software design, and even style. XMLFoundation maps the data 
in raw XML to lists, 
arrays, strings, ints, and even int64's in the application layer.  All 
of these data types have been 
supported for over a decade already.  New interfaces in the 2012 version
 
support mapping char(1 byte), short(2 bytes), and char buf[n bytes] to 
fully 
complete the mapping to every native C++ data type.  The foundational 
GString is now indexed by 64 bit addressing which pushes all xml 
document size 
limitations into almost infinity.  This long addressing scheme has been 
added in such a way that 32 bit applications will still use 64 bit 
addressing 
granting them the bounds of infinity as well.  Benchmark tests confirm 
that XMLFoundation is the fastest approach for moving XML into the 
application layer.  
The overhead of pushing an extra 4 bytes on the call stack during 
tokenization is 
measurable but insignificant in light of all the stack operations 
eliminated by using a custom non 
SAX interface to the XML parser (Read details in the 'Faster than Fast' 
section).  On 64 bit systems there is no performance 
penalty to pay at 
all since the registers are 64 bits wide already.



</p><p align="left">The GString is such a sexy article of engineering that it gets 
used to hold all types of streamed data in an application, not just XML.  By design, the GString replaced 
ostream which the tokenizer (aka -the lexical analyzer or the XML Parser) was initially built with.  
By overloading the &lt;&lt; operator it was a very simple task to port this work 
to a better
stream class.  In the times of 2012 we now deal with file 
sizes and offsets that require 64bit indexing on the average or above average home computer.  
Granted it will be many years before the average home computer allocates 
contiguous regions of memory that large - but high end servers do it already and 
they have registers that are 64 bits wide.  To keep GString positioned to 
serve mankind in ALL situations it now uses a 64 bit index.  Target the 
future.  



</p><p align="left">A 32 bit test parsed xml containing element and attribute tags 
mapped to various lists, string and integers. This was executed while counting 
cpu cycles using the assembly code in <em>GPerformanceProfile.cpp</em> for these results 
running in a native 32 bit operating system that is not under WOW or 
virtualization:



</p><p align="left">Tokenizing with a <span style="background-color: rgb(255, 255, 0);">64</span> 
bit index in the <span style="background-color: rgb(255, 255, 0);">new</span> XMLFoundation 32 bit build on a 32 bit OS: 
(176,121) CPU cycles



</p><p align="left">Tokenizing with a <span style="background-color: rgb(255, 255, 0);">32</span> bit index in the 
<span style="background-color: rgb(255, 255, 0);">old</span>  XMLFoundation 32 
bit build on a 32 bit OS:  (170,144) 
CPU cycles



</p><p align="left">By merely widening the integer index at the lowest level of the 
XML parser it caused the machine code produced by the C++ compiler to PUSH and 
POP more data onto the stack, hence it now takes more CPU cycles to process the 
same amount of XML.  If you understand what caused the difference, then you 
can understand why the XMLFoundation  is preferable to SAX if you want the 
fastest solution.  Truly this is the fastest solution on earth for processing XML 
in 32 bit, even though it is now optimized for 64 bit.  
The fastest solution will be the one selected to process the largest XML data 
sets in the world because the decision will be made by an engineer not a 
politician.  Those data sets will need this very large indexing scheme.  
Smaller data sets no longer need to worry that some freak occurrence (an 
exception) might (however unlikely) surpass 32 bit indexing thresholds.  
English words fail to express what raw numbers so emphatically and eloquently 
assert is the fastest way to process XML.  Aside from all this raw 
horsepower produced through efficient algorithmic design, the application source 
code that uses XML is organized and simple.



</p><p align="left">The 2012 version also supports a new interface to access unparsed CDATA 
from the object directly in the memory buffer passed into the lexical analyzer 
that algorithmically instantiates objects for you.  Several new examples 
have been added in December advancing the example documentation to include 
<a href="#Inheritance%20of%20Mapping">Inheritance of Mapping</a> explaining how to 
use base object mappings.  Another Sample explains custom 
<a href="#Parsed%20And%20Unparsed">Parsed and Unparsed Object Data</a> handlers.  
If a picture is worth a thousand words, an example is worth ten thousand.  
"Open Source" projects are frequently unsupported and undocumented, however you 
will find that the ongoing commentating of source code is continuously being 
maintained and developed to make the toolkit more useful and productive in the 
hands of people who are new to using it.  The detailed documentation is all 
in the source code, right where you need it.  For example a comment was 
just recently added into ListAbstraction.h just above the 
StringCollectionAbstraction class that explains how that base class is used to 
store ANY data type into ANY data structure.  That comment links to a new 
class called CDoubleArrayAbstraction in AbstractionsMFC.h that stores the data 
type "double" into MFC's array implementation called CArray.  While the 
implementation was the point of interest of one person, the comments added will 
be the point of interest to even more people that need some other data type in 
some other kind of data structure.

</p>
<p align="left">As many of you know this project had no updates for 2 years 
while I was in prison serving time for "Escape".



</p><p align="left">The details of my case should disturb you.  I would have 
been killed if some authorities had their way but I lived to code another day so 
you can be certain that I am going to make the most of every keystroke now.  
I added a folder called "Disturbing" to the root folder of the source code 
distribution that contains some serious arrays of 1's and 0's in various 
formats.



</p><p align="center">Welcome to XMLFoundation  



</p><p align="left">
      
</p><p>
</p><p align="left">
    

</p><p align="left">
    
</p><p align="left">
      
</p><p>
</p><p align="left">
      
</p><p>
</p><p align="left">
    

</p><p>
</p><p align="left">
    
</p><p align="left">
      
</p><p>
</p><p align="left">
      
</p><p>
</p><p align="left">
    

</p><p>
</p><p align="left">
    
</p><p align="left">
      
</p><p>
</p><p align="left">
      
</p><p>
</p><p align="left">
    

</p><p>
</p><p align="left">
    
</p><p align="left">
      
</p><p>
</p><p align="left">
      
</p><p>
</p><p align="left">
    

</p><p>
</p><p align="left">
    
</p><p align="left">
      
</p><p>
</p><p align="left">
      
</p><p>
</p><p align="left">
    

</p><p>
</p><p align="left">
    
</p><p align="left">
      
</p><p>
</p><p align="left">
      
</p><p>
</p><p align="left">
    

</p><p>
</p><p align="left">
    
</p><p align="left">
      
</p><p>
</p><p align="left">
      
</p><p>
</p><p align="left">
    

</p><p>
</p><p align="left">
    
</p><p align="left">
      
</p><p>
</p><p align="left">
      
</p><p>
</p><p align="left">
    

</p><p>
</p><p align="left">
    
</p><p align="left">
      
</p><p>
</p><p align="left">
      
</p><p>
</p><p align="left">
    

</p><p>
</p><p align="left">
    
</p><p align="left">
      
</p><p>
</p><p align="left">
      
</p><p>
</p><p align="left">
    

</p><p>
</p><p align="left">
    
</p><p align="left">
      
</p><p>
</p><p align="left">
      
</p><p>
</p><p align="left">
    

</p><p>
</p><p align="left">
  

</p><table class=" ArticleTable" align="center" height="287" width="70%">
    <tbody><tr>
      <td width="47%"><p align="left">1. <a href="#XML%20in%20the%20Foundation">XML In the Foundation</a>

</p></td><td width="53%"><p align="left">




<span id="ArticleContent9">
		14. <a href="#GUI%20Objects">GUI Objects</a>

</span>

</p></td>

</tr><tr><td width="47%"><p align="left">2. <a href="#The%20Solid%20Foundation%20">The Solid Foundation</a>

</p></td>

<td width="53%"><p align="left">




<span id="ArticleContent10">
15. <a href="#CORBA%20Objects">CORBA Objects</a>

</span>

</p></td>

</tr>

<tr><td width="47%"><p align="left">3. <a href="#History%20and%20Future">History and Future</a>

</p></td>

<td width="53%"><p align="left">




<span id="ArticleContent11">
16. <a href="#COM%20Objects">COM Objects</a>

</span>

</p></td>

</tr>

<tr><td width="47%"><p align="left">4. <a href="#The%20Need%20for%20Objects%20from%20XML">The Need for Objects from XML</a>

</p></td>

<td width="53%">




<span id="ArticleContent12">
<p align="left">17. <a href="#Object%20Caching%20and%20Instance%20Management">Object Caching and Instance Management</a></p>
</span>
	</td>

</tr>

<tr><td width="47%"><p align="left">5.<a href="#Best%20of%20Breed"> Best of Breed</a>

</p></td>

<td width="53%">




<span id="ArticleContent13">
18. <a href="#Parsed%20And%20Unparsed">Parsed and Unparsed 
        Object Data</a></span></td>

</tr>

<tr><td width="47%"><p align="left">6.<a href="#Don%27t%20Be%20Square"> Don't Be Square</a>

</p></td>

<td width="53%"><p align="left">




<span id="ArticleContent14">
19. 




<span id="ArticleContent6"> <a href="#FiveLoaves">FiveLoaves (aka ServerCore)</a></span></span></p></td>

</tr>

<tr><td width="47%"><p align="left">7. <a href="#Learn%20To%20Think%20Outside%20The%20Box">Learn To Think Outside The Box</a>

</p></td>

<td width="53%"><p align="left"><span id="ArticleContent15">
20. 




<span id="ArticleContent5"> <a href="#Plugins">Plugins and Language Drivers</a></span>

</span>

</p></td>

</tr>

<tr><td width="47%"><p align="left">8. <a href="#New%20World%20Order">New World Order</a>

</p></td>

<td width="53%"><p align="left">




<span id="ArticleContent16">
21. 




<span id="ArticleContent4"> <a href="#FiveLoaves%20Tunneling">FiveLoaves Tunneling
        and Messaging</a></span></span></p></td>

</tr>

<tr><td width="47%"><p align="left">9. <a href="#Faster%20than%20Fast">Faster than Fast</a>

</p></td>

<td width="53%"><p align="left"><span id="ArticleContent17">
22.<a href="#Translating XML"> </a></span><span id="ArticleContent19">
<a href="#Translating XML">Translating XML</a></p>
</span>
	</td>

</tr>

<tr><td width="47%"><p align="left">10. <a href="#Object%20Factorization">Object Factorization</a>

</p></td>

<td width="53%"><p align="left">23. 




<span id="ArticleContent20">
<a href="#Mapping XML to Bits of a Byte">Mapping XML to Bits of a Byte</a></span></p></td>

</tr>

<tr><td width="47%"><p align="left">11.<a href="#Member%20Mapping"> Member Mapping</a>

</p></td>

<td width="53%">
<p align="left">24.




<span id="ArticleContent21">




<span id="ArticleContent22">
<span id="ArticleContent23">
<span id="ArticleContent3"> <a href="#XMLFoundation%20for%20Java">XMLFoundation for Java</a></span></span></span></span></td>

</tr>

<tr><td width="47%">




<span id="ArticleContent7">
	12. <a href="#Inheritance%20of%20Mapping">Inheritance of 
        Mapping</a>

</span>
	</td>

<td width="53%"><span id="ArticleContent18">
25. <span id="ArticleContent2">
        <a href="#About%20the%20author%28s%29%20of%20XMLFoundation">About the
        author(s) of XMLFoundation</a></span></span></td>

</tr>

<tr><td width="47%"><p align="left">




<span id="ArticleContent8">
	13. <a href="#Object%20Model%20Navigation">Object Model Navigation</a>

</span>

</p></td>

<td width="53%"><p align="left">




<span id="ArticleContent0">26. </span>




<span id="ArticleContent1"> <a href="#Conclusion">Conclusion</a></span>

</p></td>

</tr>

</tbody></table><div align="left">
  </div><div align="left">
</div><div align="left">


</div><h2>
</h2><h2>
</h2><h2><a name="XML in the Foundation">XML in the Foundation</a></h2>

As the name suggests it provides a foundation for XML
support in an application, however this is much more than just another XML
parser.  It applies a unique approach to handling XML that allows your
application code to focus on the application rather than traversing DOM or
subscribing to SAX events.  The most unique feature of the
XMLFoundation is the object oriented encapsulation that provides XML support in
the application layer.  XMLFoundation allows you to easily integrate XML
with your GUI, or with your server objects,  and it natively supports COM, DCOM,
and CORBA objects.


XMLFoundation contains a small, fast, and portable XML
tokenizer that has been refined and optimized in many large software projects.  My involvement with XML
pre-dates the finalization of the XML 1.0 recommendation by W3C.  For years,
the only XML Parser that could match XMLFoundation tokenization performance was
"Xpat" by James Clark - but as you will see the unique ability to
bypass DOM and SAX altogether makes XMLFoundation the fastest solution available for
moving XML to and from application layer objects - and it requires far less
lines of code to do it.  


The performance of the stack based XML parser is at the top
of its class for non-validating parsers.  Parsing and tokenization is only
half the task, the other half is getting the results into the member variables,
lists, and objects that they need to be in to be useful in the application layer
- it is in that task that XMLFoundation is in a class of its own.  The
performance is unparalleled because the memory buffer that contains the source
XML parses directly into your custom class objects without ever being copied or
temporarily stored in a DOM tree.  It parses directly into your lists,
objects, arrays, indexed data structures, and all native C++ data types. 
It even has support for common containers of element data such as MFC CStrings. 
It's been used in Java too. 
That said, speed of execution is less impressive than the speed of development
and overall reduction in lines of code required to effectively use XML in your
application.


XML is in the Foundation, but the foundation does much more
than just XML.  It is also a web services framework implemented in
ServerCore.cpp.  It can be extended several ways for HTTP as well as for
other protocols.  This allows you to to build your application on a
multi-threaded server blueprint that has been used on many platforms and it has
been used to build servers that are not even XML based, but needless to say it
works great for building an XML based server.  The services framework
supports a unique design approach for both static and dynamic server extensions
and examples of both - but XMLFoundation does even more than XML and Web 
Services.
<h2><a name="The Solid Foundation">The Solid Foundation </a></h2>
<p>
If you are building an application that does not use XML
and never will..... XMLFoundation is still a very valuable tool available to
solve many very common development tasks.  The <span class="emphasis"> data structure classes</span> alone
( <span class="emphasis">List, Hash, Stack, Tree, Array, QSort </span>) are very useful.  They
all have "<a href="http://www.oodesign.com/iterator-pattern.html">Iterator</a>"
objects so that data structures can be
read-referenced by multiple threads at the same time without blocking.  The interface is
standard to all data structures.  If you
find MFC or Rogue Wave Standard C++ library data structures useful, you will likely find XMLFoundation data
structures even more so.</p>
<p>XMLFoundation also has <span class="emphasis"> standard algorithm implementations</span>
( <span class="emphasis">Encryption, Compression, Data hash, Encoding </span>).  These are based on the
works of other authors.  They have been included into the XMLFoundation in
a simplified build format.  They all compile under C++, so if you are using
them on AS/400, AIX, Solaris, Linux, or other like platforms - you do not even
need to reference a C compiler from the makefile, only your C++
compiler.  They are also organized into single .CPP files for each
implementation - often a consolidation of many individual C source files in the
original authors publications.</p>
<p>XMLFoundation also has a plethora of <span class="emphasis"> application utilities</span>
including ( <span class="emphasis">Sorts, Performance Timers, Disk Directory, Exceptions, 
INI Profiles,
Caching, String, Stream </span>).  XMLFoundation has many utilities that MFC does not. 
They are complete, comment documented with examples, and thoroughly tested on
many software projects.</p>
<p><span class="emphasis">XMLFoundation is
very portable</span>.  It builds on all versions of Windows (Win95 through
Windows8 and Windows Mobile).  Portions were initially developed on a RISC machine, and
it was used in Solaris and Linux as early as 2001.  Some of the compilers that have been used to build XMLFoundation
include: CC5.0, Xlc, <strong> </strong>IntelC++,  KAIc++,
ForteC++, Visual C++, Borland C++, and eMc++.  However I believe it works with any C++
compiler <a href="http://www.compilerconnection.com/companies/companies.htm">found
here</a>, because it does not use namespaces, iostreams, or STL - all areas that
are prone to porting problems from my experience.  It does have template
classes but their inclusion is optional as part of the implementation rather
than part of the foundation. XMLFoundation and all the sample
applications have recently been built and verified on Ubuntu and Fedora. The
source is distributed with VC6 makefiles so that the source can be imported into 
projects using every version of the Microsoft compilers from 1998 through Visual 
Studio 2010.   <span style="background-color: rgb(255, 255, 0);">Now the source includes a Visual Studio 2012 project file with 32 and 64 bit 
targets defined.</span></p>
<p>The build dependencies are meticulously correct.  Smart linkers leave out
everything you don't use, so don't expect to see code bloat as a
punishment for using XMLFoundation.  Other development libraries were
not designed as well from a build perspective.  Your application will not
load any DLL's as a result of using the XMLFoundation.   <a href="http://cid-d7ec275e76d295cf.skydrive.live.com/self.aspx/Software/Xfer%20Eval.zip">Xfer
is another project I manage</a> that is built on the XMLFoundation for the
platform independence - the code is tight and the product(s) built on
XMLFoundation reflect that.</p>
<p>I suppose an entire article could be written about each of
the foundational classes, and I'm certain that they will be written.  They
are all well commented and coded with a highly experienced approach.  The
String class uses stack space when possible to avoid heap allocations. 
It's the best string implementation I've ever seen.  The INI Profile class
uses triggers that allows your application to pick up real-time configuration
changes much like <code>RegNotifyChangeKeyValue()</code> in the Windows SDK.  Exceptions
can be configured to unwind the call stack to a memory buffer like Java's <code>printStackTrace()</code>.  The Tree has an iterator.  The Directory can
delete recursively - on all platforms.  The Stack is entirely inline, with
standard and macro methods - It could not be any faster if it was coded directly
in assembly.  The <code>StringList</code> puts MFC's <code>CStringList</code> to shame, just look at
the interfaces.  The GHash puts Microsoft's <code>CMapStringToPtr</code> to shame. 
It is <em>unspeakably</em>  faster.  Look at the "MFCTypesFromXML" example and see for
yourself.</p>
<h2><a name="History and Future">History and Future</a></h2>
<p>You cannot build a house on foundation of wet cement that
has not cured yet.  With cement, minimizing stress prior to curing
minimizes cracking in your foundation.  The same is true of software. 
The XMLFoundation is solid and completely cured.  It would be too bold to say that the
XMLFoundation has no bugs in, but it has none that I am aware of and the code 
has been heavily used. It is a complete foundation. Building an application on 
any foundation like Java 1.0 or .NET 1.0 or anything 1.0 means that if you don't 
get slowed down by the bugs, you will be slowed down when you find all the 
missing functionality.  This code was first released to the public July 4, 
2002 - the XMLFoundation was already very mature for it's age - it came from a
good family - it's mother had already been used on the largest software project
in the world.  Since then I have built several complex applications on
it and many others have as well.  It was completely stress tested with SMP hardware during a recent
Fortune 50 proof of concept implementation.  XMLFoundation interfaces are
well established constants, no longer a curing foundation that is still forming.</p>
<p>The mother of the XMLFoundation was "The XML Object
Framework", born in 1998 &amp; 1999(it was a long labor) for a client of mine.  The XMLFoundation was
born the following year.  The XMLFoundation sported a completely new
implementation of the xml parser based on the custom GString stream class that
was also born in 2000.  XML Journal Magazine reviewed a product built on
the early XMLFoundation object factorization and called it "5 Star / World
Class" in XMLJournal Magazine Volume 2 Issue 7 (note: they did not review XMLFoundation they reviewed TransactXML). 
XMLFoundation was heavily developed the following two years before it became 
public in 2002.  This project is mature and stable.</p>
<p>XMLFoundation absolutely IS the future in certain technology subsets.  It is a gift to the world of engineering, and 
it comes with all the source code.  Universities that want to teach
algorithms, applications, or  OO Design will find the XMLFoundation to be a
great source code to base a curriculum on.  Independent authors who want to
write about cutting edge technology will find XMLFoundation a worthy
subject.  The future was written in the past.</p>
<h2><a name="The Need for Objects from XML">The Need for Objects from XML</a></h2>
<p>XML is data.  âObjects from dataâ is not a new concept. 
Programmers have been doing that for years, even before they were called
objects.  We still need to get data into objects today.  The data
can be XML or a result set, and the object might be a CDialog, a CORBA Object, a
COM object, or your own invention.  You still need to get the same thing done. 
Programmers have been doing this as long as there have been programmers.</p>
<p>If you apply enough force you can make the cube fit into the round
hole.  If you apply enough force you can do anything - even police
California.  The brute force approach is
to parse the XML into a DOM tree, and traverse the tree to gather the data
required by application/object variables.  This approach causes volumes of
âsimpleâ source code to move data from XML into Structured Objects,  a
poor approach with respect to implementation time and long term maintenance.</p>
<p>Alternatively, the OO approach generalizes this process into reusable
functionality that enables objects to serialize to and from XML directly. 
OO is pronounced ohhh-ohhh - and it is short for Object Oriented (incase you
didn't know) - it's poetic tech lingo - a code of it's own.</p>
<p>
Software developers of every language have a similar need.  They must
either:</p>
<ol type="A">
<li>Write their own Object-XML tools,</li>
<li>Find some production quality framework ready to use or,</li>
<li>Use brute force and budget for maintenance programmers.</li>
</ol>
<h2><a name="Best of Breed">Best of Breed</a></h2>
<p>We can mostly rule out option A because it takes a lot of
time and the purpose of the project is to build product not tools.  Option
C is also unwise if you have any long term plans for your product or want to be
able to quickly add new features.  Option B leaves several paths and it
wouldn't be right for me to toot my own horn and tell you that XMLFoundation is
the best option available in the entire software industry to accomplish this
fundamental task - so I encourage you to research this yourself and I expect
that you will agree XMLFoundation is not just the best free solution, it's the
best solution.</p>
<p>It's difficult to directly compare XMLFoundation to other
solutions because the utilities in XMLFoundation, and many of the features in
XMLFoundation are not found in other solutions.  That said, here is a
starting point for your own research:</p>
<p>Microsoft developed the "Xml.<code>Serialization.XmlSerializer</code>",
for C# but it only supports shallow serialization(no nested or complex objects)
and it lacks many other features found in the XMLFoundation. I would wager that
even the limited support it does provide is slower than XMLFoundation but I have
not put the two technologies to a speed comparison.</p>
<p>Liquid Technologies has a nice XML Serialization library( 'XML Data Binding' in
Liquid XML Studio $246) that is mostly fast, but I am aware that when
serializing small strings it's about 5 times slower than MSXML. Most likely this
is due to heap allocations. XMLFoundation avoids most heap allocations for small
strings. Once again I've never compared the two in a performance race.</p>
<p>A product called CMarkup is a C++ library that sells for $249 and has more
features than what Microsoft put together (enough that it can actually be used
for real world development). It does not support parsing directly into the kinds
of data structures that XMLFoundation does (tree, hash, etc) so a performance
comparison would need to include that. I have never put it to a side by side
performance test with XMLFoundation but if anyone reading this did it, I would
like to hear the results.</p>
<p>IBM Developer Works has posted 2 or more XML Serialization libraries 
but they are based on an external XML Parser - so by nature of their 
design 
they must be slower.</p>
<p>XMLFoundation is free.  No strings attached. There is not even a 
'professional' version that costs money - this is the professional 
version.</p>
<p>The list goes <a href="http://www.rpbourret.com/xml/XMLDataBinding.htm#xmlfoundation">on, and on, and on, and on</a> of likeminded solutions.</p>
<h2><a name="Don't Be Square">Don't Be Square</a></h2>
<p>From a procedural perspective we put data in square sets just to make
 programming simple.  Consider this example data that is a "Customer" 
with a list of "Orders" where each order has a list of "LineItems".  
That is not a square dataset - but for 
the sake of the application layer we have forced it to be square for the
 last 4 decades.</p>
<table class="ArticleTable" width="67%">
  <tbody><tr>
    <td width="14%">CUSTOMER</td>
    <td width="14%">CUST_ID</td>
    <td width="14%">ORDER_ID</td>
    <td width="14%">ORDER_DATE</td>
    <td width="14%">LINEITEM_ID</td>
    <td width="14%">LINEITEM_DESC</td>
    <td width="14%">PRICE</td>
  </tr>
  <tr>
    <td width="14%">Brian</td>
    <td width="14%">777</td>
    <td width="14%">1</td>
    <td width="14%">July 4, 1777</td>
    <td width="14%">7</td>
    <td width="14%">Firecrackers</td>
    <td width="14%">$111</td>
  </tr>
  <tr>
    <td bgcolor="#ff0000" width="14%">Brian</td>
    <td bgcolor="#ff0000" width="14%">777</td>
    <td bgcolor="#ff0000" width="14%">1</td>
    <td bgcolor="#ff0000" width="14%">July 4, 1777</td>
    <td width="14%">14</td>
    <td width="14%">Ariel Shells</td>
    <td width="14%">$222</td>
  </tr>
  <tr>
    <td bgcolor="#ff0000" width="14%">Brian</td>
    <td bgcolor="#ff0000" width="14%">777</td>
    <td bgcolor="#ff0000" width="14%">1</td>
    <td bgcolor="#ff0000" width="14%">July 4, 1777</td>
    <td width="14%">21</td>
    <td width="14%">Party Favors</td>
    <td width="14%">$444</td>
  </tr>
  <tr>
    <td bgcolor="#ff0000" width="14%">Brian</td>
    <td bgcolor="#ff0000" width="14%">777</td>
    <td width="14%">2</td>
    <td width="14%">July 4, 2009</td>
    <td width="14%">28</td>
    <td width="14%">Attorney Fees</td>
    <td width="14%">$222</td>
  </tr>
  <tr>
    <td bgcolor="#ff0000" width="14%">Brian</td>
    <td bgcolor="#ff0000" width="14%">777</td>
    <td bgcolor="#ff0000" width="14%">2</td>
    <td bgcolor="#ff0000" width="14%">July 4, 2009</td>
    <td width="14%">35</td>
    <td width="14%">State Fines</td>
    <td width="14%">$555</td>
  </tr>
</tbody></table>
<p>The repetition in red filled the hole in to make non-square data be
square.  The data in red is normally a pointer reference to the last sort
break at the DBMS kernel level, but various toolsets often expand it long form
so that 1 instance of a "Row" object does not rely on the data in
another instance.  It's a terrible situation that has plagued applications
for as long as I can remember.  The problem is that in reality there is no
such thing as a "Row" object - it was more of a temporary/tool-object
to get the data into real objects like Customers, Orders and LineItems.  Countless data access
products in the form of VBX, OCX, ActiveX and various frameworks and libraries
serve up square data sets to applications that MANUALLY code the transfer of
data into their application objects with volumes of code that looked something
like this:</p>
<pre lang="C++">Customer::Load()
{
    <span class="highlight">Tool</span>.GetData()
   
    while( Tool.MoreRows() )
    {
         <span class="highlight">Row</span> = Tool.GetNextRow();
         // Loop until we find a sort break on OrderID
         if  (<span class="highlight">Row</span>.GetColumn("Order_ID") != LastOrderID)
         {
              LastOrderID = <span class="highlight">Row</span>.GetColumn("Order_ID")
     
              // Make an Order object - set the values - then add it to the customer
              Order = new  OrderObject;
              Order.date = <span class="highlight">Tool</span>.GetColumn("Order_Date")
              Order.id = <span class="highlight">Tool</span>.GetColumn("Order_ID")
              AddOrderToCustomer(Order)
         }
         // Make a new line item object - set the values - then add it to the order
         LineItem = new  LineItemObject;
         LineItem.id = <span class="highlight">Tool</span>.GetColumn("LineItem_ID")
         LineItem.desc = <span class="highlight">Tool</span>.GetColumn("LineItem_Desc")
         LineItem.price = <span class="highlight">Tool</span>.GetColumn("Price")
     
         Order.AddLineItem( LineItem )
    }
}</pre>
<p>Notice all the use of <code>Tool</code> that
represents some sort of data set tool, class or library.  Building software
to accomplish this task of copying data into objects without such a tool would
dramatically increase the lines of code required to move the square dataset into
your application objects.  Knowing what tools to use can be the difference
between the success or failure of an entire project.  One bad tool, or one
missing tool can make all the difference in the world to a software developer.</p>
<h2><a name="Learn To Think Outside The Box">Learn to Think Outside the Box</a></h2>
<p>This is the same example data from the square result set represented in XML:</p>
<pre lang="xml">&lt;Customer id=777&gt;
    &lt;Name&gt;Brian&lt;/Name&gt;
    &lt;Order id=1&gt;
        &lt;Date&gt;July 4, 1777&lt;/Date&gt;
        &lt;LineItem id=7&gt;
            &lt;Desc&gt;Firecrackers&lt;/Desc&gt;
            &lt;Price&gt;111&lt;/Price&gt;
        &lt;/LineItem&gt;
        &lt;LineItem id=14&gt;
            &lt;Desc&gt;Ariel Shells&lt;/Desc&gt;
            &lt;Price&gt;222&lt;/Price&gt;
        &lt;/LineItem&gt;
        &lt;LineItem id=21&gt;
            &lt;Desc&gt;Party Favors&lt;/Desc&gt;
            &lt;Price&gt;444&lt;/Price&gt;
        &lt;/LineItem&gt;
    &lt;/Order&gt;
    &lt;Order id=2&gt;
        &lt;Date&gt;July 4, 2009&lt;/Date&gt;
        &lt;LineItem id=72&gt;
            &lt;Desc&gt;Attorney Fees&lt;/Desc&gt;
            &lt;Price&gt;222&lt;/Price&gt;
        &lt;/LineItem&gt;
        &lt;LineItem id=42&gt;
            &lt;Desc&gt;State Fines&lt;/Desc&gt;
            &lt;Price&gt;555&lt;/Price&gt;
        &lt;/LineItem&gt;
    &lt;/Order&gt;
&lt;/Customers&gt;</pre>
<p>There is nothing square about XML.  XML is an <a href="http://www.brpreiss.com/books/opus5/html/page257.html">N-airy
tree</a>. That's why we naturally use DOM (Document Object Model) to traverse
the data.  For 1000's of years we thought that the world was flat. 
Engineers made it be square because that was easier for them to cope with and
now we live in the days where it begins to take it's true shape. 
Unfortunately as of 2010, the opportunity of the paradigm data shape shift has
not been harnessed by most programmers that grew up in the square world and are
only familiar with square tools.  They take the most obvious development
path.  If you presented the problem of sorting to someone who has no tools,
they will likely build a "bubble sort" - because that is the most
obvious and immediate solution.</p>
<p>Typically the XML is parsed into a tree structure.  This means that the
linear and contiguous memory buffer of source XML is <strong>copied</strong> into many
fragmented pieces of memory across the heap - each element and in many cases
each token gets it's own heap space.  This makes the XML elements
and attributes programmatically accessible with loops and recursion, just like <span class="highlight">Tool
</span>did for square datasets.  The XML parser puts the Elements and
Attributes into this temporary fragmented memory tree structure so that the
application programmer can get at the information to copy it <strong>once more</strong>
into a final structure that can be displayed on the GUI or used by the
application.  It is likely going to take as much or more code to get from
the temporary DOM tree into the objects as it did to get from the square result set
into the objects.  In many cases it will require recursion that is
difficult to debug - much more difficult than the old fashioned iterative code
required to copy from square result sets.  Below is a code sample of some common tasks:</p>
<pre lang="C++"><font color="#008000">//Due to the large amount of code to change a DOM node name this article only 
//    includes the basic steps involved.  This is what it takes to change an element 
//    tag name using DOM, it's much more involved using SAX.  
-------------------------------------------------------
// 1. create a new node with the desired tag name 
// 2. preserve old value to copy later 
// 3. move all children of current node to new node 
// 4. get parent of current node and replaceChild the current node with the new node 
// 5. copy old value or new value to new node 
// NOTE: Attributes are handled differently! </font>
<font color="#008000">
// This is how to add a new attribute using DOM </font>
MSXML::IXMLDOMNamedNodeMapPtr pAttrList = m_pCurNode-&gt;Getattributes();
_bstr_t bstrAttrName = (_bstr_t)(LPCTSTR)m_strName;
MSXML::IXMLDOMAttributePtr pNewAttr = m_pDOMDoc-&gt;createAttribute(bstrAttrName);
_bstr_t bstrAttrValue = (LPCTSTR)m_strValue;
pNewAttr-&gt;PutnodeValue((_variant_t)bstrAttrValue);
pAttrList-&gt;setNamedItem(pNewAttr);
<font color="#008000">// TODO: The user must first search to be sure the attribute name is unique, or your XML will be invalid! 
// One of the well-formedness constraints that the XML 1.0 specification lists is that no attribute name  
// may appear more than once in the same start tag or empty element tag.  DOM never deals with this issue. 
// XML is case sensitive, so attribute "Name" is different from attribute "name", some tools built into DOM 
// sure would have been useful - good thing we have the XMLFoundation. </font>
AddNodeToTree(pNewAttr, m_hCurItem);</pre>
<h2><a name="New World Order">New World Order</a></h2>
<p>The square world is becoming part of history like the flat world.  I 
remember back in the early 90's we tried to rid ourselves of the square 
world with something 
called "The Object Database".  It was a great concept and the only 
reason square prevailed against it is because nobody could implement an 
Object 
Database that was fast enough.  Who cares how clean the code is if the 
application is dysfunctional because it is too slow?  This is why 
XMLFoundation is so performance oriented - that's what it takes to 
change the world.  The clean code alone is not enough.</p>
<p>Now I'll explain how to accomplish the task of loading up your object
 with the information in the XML using a fully object oriented 
approach to data handling.  Customer, Order, and LineItem are derived 
from <code>XMLObject</code>.  They must implement 1 virtual method called 
<code>MapMembers()</code> 
that would look like this:</p>
<pre lang="C++"><font color="#0000FF">void</font> Customer::MapXMLTagsToMembers()
{
    MapMember(&amp;m_OrderList, Order::GetStaticTag());
    MapAttribute(&amp;m_nCustomerID, "id");
    MapMember(&amp;m_strName, "Name");
}
<font color="#0000FF">void</font> Order::MapXMLTagsToMembers()
{
    MapAttribute(&amp;m_nOrderID, "id");
    MapMember(&amp;m_LineItemList, LineItem::GetStaticTag());
    MapMember(&amp;m_strDate, "Date");    <font color="#008000">// can also be mapped to a date/time object</font>
}

<font color="#0000FF">void</font> LineItem::MapXMLTagsToMembers()
{
    MapAttribute(&amp;m_nLineItemID, "id");
    MapMember(&amp;m_strDesc, "Desc");
    MapMember(&amp;m_strPrice, "Price");    
}</pre>
<p>Now all the object assignment and creation code is summed up into this one line.</p>
<pre lang="cs">// This assigns ALL member variables and creates sub-objects. 
Customers.FromXML( pzXML )</pre>
<p>If you had a trace statement in the constructor of the Order, you 
would see that it was called  for every appearance of an Order in the 
XML.</p>
<p>Now suppose you wanted to manipulate some member variables then regenerate 
the XML: just assign your member variables normally then regenerate your XML - that's just as easy.</p>
<pre lang="C++"><font color="#0000FF">char</font> *pzXML = Order.ToXML()</pre>
<p><code>MapXMLTagsToMembers()</code> defines everything needed for your objects to <em>read</em>
or <em>write</em> XML as a base method.  Without the XMLFoundation you
would  have to code all that looping and mapping 2 times if you wanted both
reading and writing XML.  Without the XMLFoundation you will have a larger
maintenance issue if any XML document structure changes because you'll have to
hunt through your looping and recursion routines to find the Element name to
change.  XMLFoundation provides countless other niceties such as mapping
any number of XML tags to the same member, and conditional inclusion of members
in the output XML based on tag name or the member state such as DIRTY indicating
that the member was updated and you only want <code>ToXML()</code> to generate a delta of the
data rather than the entire set.  You can specify element order or have
them output alphabetically.  Common needs that can all be accomplished in 1
line of code rather than pages of code.</p>
<pre lang="C++"><font color="#008000">//The following code is so involved using DOM only the basic steps are described.
//This is what it takes to change an element tag name using XMLFoundation.
-------------------------------------------------------
// This is how backward compatibility is achieved when Element tag
// names change. For example, if m_nVersion is mapped to an Element
// named "VersionNumber" but you want all future protocols to refer to this 
// Element as to "ProtocolVersion". This is achieved by the following code:
// This allows either "VersionNumber" or "ProtocolVersion" to set the value of 
// m_nVersion, but always refers to it as "ProtocolVersion" while serializing XML.</font>
MapMember(&amp;m_nVersion,"VersionNumber");
MapMember(&amp;m_nVersion,"ProtocolVersion");
SetMemberSerialize("VersionNumber", false );


// This is how to add a new attribute using XMLFoundation 
// if nUpdate=1 the attribute list will be searched and updated if there is an existing 
// attribute called [pzName]if not found or if nUpdate=0 the new attribute will be added.
<font color="#0000FF">void</font> AddAttribute( <font color="#0000FF">const char</font> * pzName, <font color="#0000FF">const char</font> * pzValue, <font color="#0000FF">int</font> nUpdate=0 );</pre>
<p>It's fun to compare the differences between DOM and XMFoundation, but
 much of the functionality in the XMLFoundation cannot be compared to 
anything in 
DOM.  For example, the XMLFoundation maintains a bit flag field for each
 member that it manages.  These are the values that can be managed:</p>
<pre lang="C++"><font color="#008000">// The value does not sync with the original value set by the Object Factory</font>
#define DATA_DIRTY 0x01 
<font color="#008000">// The member has been set by either the Object or the Object Factory.</font>
#define DATA_NOT_NULL 0x02
<font color="#008000">// The member has been assigned a value from the Object Factory</font>
#define DATA_CACHED 0x04
<font color="#008000">// The member has never been assigned a value, it is uninitialized</font>
#define DATA_NULL 0x08 
<font color="#008000">// The member should be included in the xml serialization stream</font>
#define DATA_SERIALIZE 0x10</pre>
<p>The following interface uses some of the member state flags:</p>
<pre lang="C++"><font color="#008000">// When objects are populated from the XML stream, they have a state of
// Not dirty and Not null. When the members are assigned by the derived 
// class through SetMember() or SetMemberByTag() the state becomes dirty.
// When using the SetMember() or SetMemberByTag() there is no need to 
// setMemberDirty(), but if the derived class does direct assignments
// to members that should be serialized, setMemberDirty() should be called.
// if you ever want to serialize or track the state change only.
// Setting bDirty to 0 will clear the dirty flag for a member variable.</font>
<font color="#0000FF">bool</font> setMemberDirty(<font color="#0000FF">void</font> *pAddressOfMemberToSet, <font color="#0000FF">int</font> bDirty = 1);
<font color="#0000FF">bool</font> setMemberDirty(<font color="#0000FF">char</font> *pzTagNameOfMemberToSet, <font color="#0000FF">int</font> bDirty = 1);

<font color="#008000">// true if the memory state does not sync with the 
// original value set by the Object Factory</font>
<font color="#0000FF">bool</font> isMemberDirty(<font color="#0000FF">void</font> *pAddressOfMemberToCheck);
<font color="#0000FF">bool</font> isMemberDirty(<font color="#0000FF">char</font> *pzTagNameOfMemberToCheck);

<font color="#008000">// true if the member has never been assigned a value, it is uninitialized</font>
<font color="#0000FF">bool</font> isMemberNull(<font color="#0000FF">void</font> *pAddressOfMemberToCheck);
<font color="#0000FF">bool</font> isMemberNull(<font color="#0000FF">char</font> *pzTagNameOfMemberToCheck);

<font color="#008000">// true if the member has been assigned a value from the Object Factory</font>
<font color="#0000FF">bool</font> isMemberCached(<font color="#0000FF">void</font> *pAddressOfMemberToCheck);
<font color="#0000FF">bool</font> isMemberCached(<font color="#0000FF">char</font> *pzTagNameOfMemberToCheck);</pre>
<p>XMLFoundation also has many options available during the creation of the XML. DOM has nothing that compares.</p>
<pre lang="C++"><font color="#008000">/////////////////////////////////////////////////////////////////////////////////////// 
// serialization flags for ToXML() 
//////////////////////////////////////////////////////////////////////////////////////// 
// Otherwise XML tags appear in the order they were mapped </font>
#define ORDER_MEMBERS_ALPHABETICALLY       0x01  
<font color="#008000">// deeply recurse without including dirty members </font>
#define RECURSE_OBJECTS_DEEP               0x02  
<font color="#008000">// includes any member with a state of DATA_CACHED </font>
#define INCLUDE_ALL_CACHED_MEMBERS         0x04  
#define EXCLUDE_SHORT_TERMINATION          0x08
<font color="#008000">// Do not serialize any data from MapAttribute() members </font>
#define EXCLUDE_MAPPED_ATTRIBUTES          0x10  
<font color="#008000">// Do not serialize attributes that came in via XML but were unmapped with MapAttribute() </font>
#define EXCLUDE_UNMAPPED_ATTRIBUTES        0x20  
<font color="#008000">// Adds the DOCTYPE to the beginning of the XML </font>
#define INCLUDE_DOCTYPE_DECLARATION        0x40  
<font color="#008000">// includes any member regardless of it's state </font>
#define FULL_SERIALIZE                     0x80  
<font color="#008000">// include OID's only </font>
#define USE_OBJECT_MARKERS                 0x100 
<font color="#008000">// more compact, faster, less human readable, The XML will have no Tabs, Carriage returns or Linefeeds </font>
#define NO_WHITESPACE                      0x200 
<font color="#008000">// do not include empty strings in XML </font>
#define NO_EMPTY_STRINGS                   0x400 
<font color="#008000">// do not include the ObjectDataHandler registered with setObjectDataHandler() </font>
#define EXCLUDE_OBJECT_VALUE               0x800</pre>
<p>It also has a SAX like (but faster and <span class="highlight">far</span> simpler) way to subscribe to notifications.</p>
<pre lang="C++"><font color="#008000">// When a tag is encounterted that does not have a MapMember() entry
// associated with it, this handler is called for the developer
// to supply an "on-the-fly" MemberDescriptor during the Factory process.
// This is useful for dynamic objects.</font> 
<font color="#0000FF">virtual</font> MemberDescriptor *HandleUnmappedMember( <font color="#0000FF">const char</font> *pzTag );


<font color="#008000">// Generic Event Handler for custom object behavior. Abstract to reduce virtual method table
// -----------------------------------------------------------------------------------------
// nCase = "XMLAssign", (member tag, XML value, value len, null)
// when the FromXML() contains a value for a member set dirty by setMemberDirty()
// see MemberDescriptor::Set() in MemberDescriptor.cpp for details.
// nCase = "NonNumeric" (member tag, XML value, value len, null)
// when non-numeric XML data is mapped to an numeric only type.
// nCase = "EmptyString"(member tag, XML value, value len, null)
// when an empty("") value is assigned to a string, empty often differs from 'unknown' or 'unassigned'
// nCase = "ObjectUpdate" when OBJECT_UPDATE_NOTIFY is a set behavior flag. (oid, null, flags, pObjSrc)
// nCase = "MemberUpdate" when MEMBER_UPDATE_NOTIFY is a set behavior flag. (tag, value, valuelen, null)</font>
<font color="#0000FF">virtual void </font>*ObjectMessage( <font color="#0000FF">int</font> nCase, <font color="#0000FF">char</font> *pzArg1, <font color="#0000FF">char</font> *pzArg2, <font color="#0000FF">unsigned int</font> nArg3, <font color="#0000FF">void</font> *pArg4)</pre>
<h2><a name="Faster than Fast">Faster than Fast</a></h2>
<p>The approach used by XMLFoundation is faster than SAX.  Since the 
object factory and the XML tokenizer were built for each other they did 
some unusual 
tricks for each other.  The tokenizer uses a unique approach to begin 
with.  It's purely pointer based.  Tokens are structures that point 
into the source XML, except for entities that get expanded into a 
special memory region.  Tokens do not hold copies of any data.  During 
object 
factorization it becomes necessary to have the token data in a null 
terminated string format.  The big performance boosting hack is that to 
obtain null 
terminated strings, the tokenizer actually plunks a null down over the 
first byte past the end of the token data.  It keeps track of the data 
it 
clobbers and restores it before  parsing out the next token.  There are 
no event calls that needlessly push data on the stack just to 
immediately 
pop it back off.  Performance profilers showed that call stack pushes 
and pops were the single largest consumer of CPU cycles in the 
tokenization process.  
XMLFoundation eliminates them by "pulling" the data through a call to [<code>void getToken(token *tok)</code>],
 rather than the SAX approach that gets the data 
"pushed" into the application events with between 2 and 7 arguments 
depending on the token type.  SAX would be the fastest approach if the 
XMLFoundation did not exist.  The XMLFoundation is the only XML parser 
that uses this approach.  It is non-standard, 
and not in compliance with W3C interfaces to an XML Parser - For our 
uses, It's better than any W3C standard.</p>
<p>I realize that the vast majority of people who use XMLFoundation 
would never care about these grungy technical details.  To say that it 
is very fast is 
enough for most people, but I am also writing to the people at the 
Apache Foundation, and Microsoft, and IBM, W3C, and the many other 
people who have 
built their own XML Parser implementations.  Fast is an understatement. 
 Performance is a prevailing design pattern found throughout the 
XMLFoundation.  For example the <code>XMLObject</code> class is carefully designed to add minimal CPU cycles during construction because it is to the XMLFoundation 
what <code>CObject</code> is to MFC.  It has been carefully designed to 
add minimal entries to the virtual method table.  In many cases virtual 
calls were consolidated 
for that purpose.</p>
<h2><a name="Object Factorization">Object Factorization</a></h2>
<p>The Object Factory is the part of the XMLFoundation that instantiates
 objects for you based on certain element tags in the source XML. It is 
based on the same 
principle as <code>DECLARE_DYNCREATE()</code> that allows MFC to instantiate CView derived classes for you. In the XMLFoundation it is called 
<code>DECLARE_FACTORY()</code>. 
The XMLFoundation uses this macro to instantiate COM and CORBA objects as well.</p>
<p>Every object that derives from <code>XMLObject</code> must have 1 
macro in the class definition, the DECLARE macro, normally in your .h 
source 
file.  It must also have one macro at global space, often in the .cpp 
file matching the .h file - or you may choose to consolidate all of your
 IMPLEMENT 
macros in a single .cpp file.  These macro's supply the XML tag and 
'this' object's name, aka the class name.  Terminology Note: Within the 
XMLFoundation the term 'tag' is 'Element Name' and sometimes 'Attribute 
Name'.</p>
<p>These macros write a method that return new instances of 'this' 
object type.  The address of this global static function is stored 
in a structure keyed by tag name.  As the tags are encountered - during 
the xml parsing - objects are created to contain the data that they 
expect to follow.</p>
<p>If a tag is mapped to an object in a list or tree structure, then 
every time that tag is encountered at the level it is mapped it will 
create a 
new instance for you and put it in the data structure (list, tree, etc.)
  you specified with all its member variables already 
assigned from the source XML as you have them mapped.</p>
<h2><a name="Member Mapping">Member Mapping</a></h2>
<p>XMLFoundation has support for mapping to all native C++ data types.  It also has support for mapping into data container 
objects.  It has specific support for <code>RWCString</code>, <code>CString</code>, and 
<code>GString</code>, and it's very easy to add support for others by deriving from the class 
"<code>StringAbstraction</code>" and supplying the pure virtual methods 
that will enable any kind of data container class to interoperate with 
the Object Factory 
for automatic member assignments.  These are the <code>MemberMap</code> methods in
<code>XMLObject</code>:</p>
<pre lang="C++">// Map an int / long int / or very long int 
void MapMember(int *pValue,const char *pTag);
void MapMember(long *pValue,const char *pTag);
void MapMember(__int64 *pValue, const char *pTag);

// Map a string, see StringAbstraction.h for interface and samples 
void MapMember(void *pValue,const char *pTag,StringAbstraction *pHandler);

// Map an object into a hash table, binary tree, or QSort array 
void MapMember(void *pDataStructure,
                 KeyedDataStructureAbstraction *pHandler,
                 const char *pzObjectName,
                 const char *pNestedInTag = 0);

// Map a collection of Strings 
void MapMember(void *pStringCollection,     const char *pzElementName,
                 StringCollectionAbstraction *pHandler,
                 const char *pNestedInTag = 0);

// Map a dynamically growing Integer array 
void MapMember(void *pIntegerArray,     const char *pzElementName,
                 IntegerArrayAbstraction *pHandler,
                 const char *pNestedInTag = 0);

// Map a sub-object using a tag other than defined in the DECLARE_Factory 
void MapMember(XMLObject *pObj,     const char *pDefaultTagOverride = 0, 
                                     const char *pzWrapper = 0 );
// Map a collection of Objects 
void MapMember(void *pList,const char *pObjectTag,
                 ListAbstraction *pHandler,const char *pNestedInTag = 0, 
                                             ObjectFactory pFactory = 0 );
// Map a sub-object pointer to an object residing in the ObjectCache 
void MapMember(XMLObject **pObj,const char *pzTag, 
                      const char *pNestedInTag= 0, ObjectFactory pFactory=0);</pre>
<h2><a name="Inheritance of Mapping">Inheritance of Mapping</a></h2>
<p>The following code can be found in the example programs.  Inheritance
 of XML maps works intuitively and enables you to organize and manage 
your code efficiently.</p>
<pre lang="C++">class CMatter : public XMLObject
{
public:
     GString m_strWeight;

 virtual void MapXMLTagsToMembers()
 {
   MapMember(&amp;m_strWeight, "Weight");
   }
   DECLARE_FACTORY(CMatter, Matter)
   CMatter(){} 
   ~CMatter(){};
};
IMPLEMENT_FACTORY(CMatter, Matter)

//------------------------------------------------

class CLife : public 
&lt;span style="background-color: rgb(255, 0, 0);"&gt;CMatter 
{
public:
GString m_strDNA;
virtual void MapXMLTagsToMembers()
{
   MapMember( &amp;m_strDNA, "DNA");
   CMatter::MapXMLTagsToMembers(); // explicit base class call
}
DECLARE_FACTORY(CLife, Life) 
CLife(){ }
~CLife(){};
};
IMPLEMENT_FACTORY(CLife, Life)
//------------------------------------------------

class CHuman : public CLife
{
public:
GString m_strFingerPrint;
GString m_strGender;
   
virtual void MapXMLTagsToMembers()
{
     MapMember(&amp;m_strFingerPrint,"FingerPrint");
     MapMember(&amp;m_strGender,"Gender");
     CLife::MapXMLTagsToMembers(); // explicit base class call
}
DECLARE_FACTORY(CHuman, Human) 
CHuman(){} 
~CHuman(){};
};
IMPLEMENT_FACTORY(CHuman, Human)

//------------------------------------------------

char pzXML3[] = 
"&lt;Human&gt;"
"&lt;Gender&gt;Male&lt;/Gender&gt;"
"&lt;DNA&gt;1101010001010101101011000010101010&lt;/DNA&gt;"
"&lt;FingerPrint&gt;Unique&lt;/FingerPrint&gt;"
"&lt;Weight&gt;777&lt;/Weight&gt;"
"&lt;/Human&gt;";


void Main()
{
   
CHuman O;
O.FromXMLX(pzXML3);

GString strDebug;
strDebug &lt;&lt; "\n\n\nGender:" &lt;&lt; O.m_strGender &lt;&lt; " FingerPrint:" 
&lt;&lt; O.m_strFingerPrint &lt;&lt; "\n" &lt;&lt; "DNA:" &lt;&lt; O.m_strDNA 

&lt;&lt; " Weight:" &lt;&lt; O.m_strWeight &lt;&lt; "\n\n";

   
printf(strDebug);
//////////////////////
// Gender:Male FingerPrint:Unique
// DNA:1101010001010101101011000010101010 Weight:777 
//////////////////////

  
printf(O.ToXML());
//////////////////////
//&lt;Human&gt;
// &lt;FingerPrint&gt;Unique&lt;/FingerPrint&gt;
// &lt;Gender&gt;Male&lt;/Gender&gt;
// &lt;DNA&gt;1101010001010101101011000010101010&lt;/DNA&gt;
// &lt;Weight&gt;777&lt;/Weight&gt;
//&lt;/Human&gt; 
//////////////////////

CLife life;

//Notice that CLife is being created with pzXML3, 
//that is the same xml that the CHuman was created with.
life.FromXML(pzXML3);// Gender and FingerPrint are now unmapped data
strDebug.Empty();

strDebug &lt;&lt; "\n\nDNA:" &lt;&lt; life.m_strDNA &lt;&lt; " " 
&lt;&lt; "Weight:" &lt;&lt; life.m_strWeight &lt;&lt; "\n\n";

printf(strDebug);
//////////////////////
// DNA:1101010001010101101011000010101010 Weight:777
//////////////////////

printf(life.ToXML());

//////////////////////
//&lt;Life&gt;
// &lt;DNA&gt;1101010001010101101011000010101010&lt;/DNA&gt;
// &lt;Weight&gt;777&lt;/Weight&gt;
//&lt;/Life&gt;
//////////////////////</pre>
<p>So- for example, you may create an object CPlant that like the CHuman
 is derived from CLife. A CPlant would contain the elements of CLife 
(DNA) and of CMatter (Weight) by inheritance.</p>
<p>If each XML message represents a transaction it is wise to map the 
commonalities of all transactions, or groups of 
transactions into a base class that allows derivatives to inherit the 
base elements of the transaction that will only be maintained in one 
place.</p>
<h2><a name="Object Model Navigation">Object Model Navigation</a></h2>
<p>By using the XMLFoundation you inherit some powerful navigation 
features that can be used to help you debug your application with the 
Dump() member.  Because the factory manages all the object 
relationships, a new kind of object navigation arises: objects know 
their creators so an 
"Order" can know at runtime if it resides inside a list in a 
"Customer", or some other kind of object, or if it is not contained by 
another 
object at all.  This is what a full Dump() output looks like:</p>
<pre>----------------------------------------------------------------------------------
Object Dump                    My comments
----------------------------------------------------------------------------------
Object Instance name: MyOrder            Dump of Order Object
{
     string     OID = 
     string     UpdateTime = 
               References = 1                 
     --------------------------------
     Type  :string
     Tag   :OrderDate
     Value :1776-07-04                The Order Date is July 4 1776
     State :(Clean | Valid | Cached)
     Kind  :Element
     --------------------------------
     Type  :string
     Tag   :ShippedDate
     Value :2010-07-04                The Ship Date is July 4 2010
     State :(Clean | Valid | Cached)
     Kind  :Element
     --------------------------------
     Type  :List&lt;XMLObject *&gt;
     Tag   :LineItem                contains a list of 3 LineItem objects
     
     Contains:3 items
     Object Instance name: MyOrderLineItem
     {
          string     OID = 1121.0000            The 1st begins here
          string     UpdateTime = 
                    References = 26          
          --------------------------------
          Type  :string
          Tag   :Description
          Value :                    Description is empty
          State :(Clean | Null | Uncached)        here we can see that it was never
                                                assigned, it was not set to ""
          Kind  :Element
          --------------------------------
          Type  :int
          Tag   :ProductID
          Value :11                ProductID is 11
          State :(Clean | Valid | Cached)
          Kind  :Element
          --------------------------------
          Type  :string
          Tag   :UnitPrice
          Value :21.0000                Unit Price is 21.0000
          State :(Clean | Valid | Cached)
          Kind  :Element
     }
     Object Instance name: MyOrderLineItem        &lt;--- here begins the 2nd of 3 line items
     {
          string     OID = 332.5000
          string     UpdateTime = 
                    References = 21          
          --------------------------------
          Type  :string
          Tag   :Description
          Value :
          State :(Clean | Null | Uncached)
          Kind  :Element
          --------------------------------
          Type  :int
          Tag   :ProductID
          Value :33
          State :(Clean | Valid | Cached)
          Kind  :Element
          --------------------------------
          Type  :string
          Tag   :UnitPrice
          Value :2.5000
          State :(Clean | Valid | Cached)
          Kind  :Element
     }
     Object Instance name: MyOrderLineItem
     {
          string     OID = 7234.8000
          string     UpdateTime = 
                    References = 23          
          --------------------------------
          Type  :string
          Tag   :Description
          Value :
          State :(Clean | Null | Uncached)
          Kind  :Element
          --------------------------------
          Type  :int
          Tag   :ProductID
          Value :72
          State :(Clean | Valid | Cached)
          Kind  :Element
          --------------------------------
          Type  :string
          Tag   :UnitPrice
          Value :34.8000
          State :(Clean | Valid | Cached)
          Kind  :Element
     }
}</pre>
<h2><a name="GUI Objects">GUI Objects</a></h2>
<p>This is an example of what is involved to get XML to the GUI.  The XML is somewhat complex to show how simple the code will 
be.  The XML is a "Customer" with a list of "Orders" where each order has a list of "LineItems".  This is the XML:</p>
<pre lang="xml">&lt;Customer&gt;
     &lt;ContactName&gt;New Dude&lt;/ContactName&gt;
     &lt;City&gt;Antioch&lt;/City&gt;
     &lt;Country&gt;All of them&lt;/Country&gt;
     &lt;Order&gt;
          &lt;ShippedDate&gt;1997-09-02&lt;/ShippedDate&gt;
          &lt;OrderDate&gt;1997-08-25&lt;/OrderDate&gt;
          &lt;LineItem&gt;
               &lt;UnitPrice&gt;45.6000&lt;/UnitPrice&gt;
               &lt;ProductID&gt;28&lt;/ProductID&gt;
           &lt;Description/&gt;
          &lt;/LineItem&gt;
          &lt;LineItem&gt;
               &lt;UnitPrice&gt;18.0000&lt;/UnitPrice&gt;
               &lt;ProductID&gt;39&lt;/ProductID&gt;
           &lt;Description/&gt;
          &lt;/LineItem&gt;
     &lt;/Order&gt;
     &lt;Order&gt;
          &lt;ShippedDate&gt;Futuristic&lt;/ShippedDate&gt;
          &lt;OrderDate&gt;Tomorrow&lt;/OrderDate&gt;
          &lt;LineItem&gt;
               &lt;UnitPrice&gt;1234567.77&lt;/UnitPrice&gt;
               &lt;ProductID&gt;1234567&lt;/ProductID&gt;
              &lt;Description/&gt;
          &lt;/LineItem&gt;
     &lt;/Order&gt;
&lt;/Customer&gt;</pre>
<p>Notice that the XML foundation will parse directly in to the CStrings
 that are already DDX bound to 
MFC's UpdateData().  This is accomplished through Multiple Inheritance. 
 Our Dialog class derives from both MFC's CDialog, and XMLFoundation's 
XMLObject.</p>
<p>The sample application reads XML and displays it in the GUI where it 
can be changed by the user, then saved back out to XML that reflects 
the users changes.</p>
<p>The complete code for this example is in "XMLDialog", but for the 
purpose of understanding what it takes to integrate XMLFoundation 
with an MFC Dialog this shows you ALL the code of interest.</p>
<pre lang="C++">////////////////////////////////////////////////////////////// 
// Begin XMLDialog.h 
#include "xmlObject.h" 
#include "GList.h" 

class CXMLDialogDlg : public CDialog, public XMLObject
{
    //This is XMLFoundation releated code
     GList m_lstOrders;
     virtual void MapXMLTagsToMembers();
     virtual void *ObjectMessage( int nCase, char *pzArg1, char *pzArg2,
         unsigned int nArg3 = 0, void *pArg4 = 0 );
     DECLARE_FACTORY(CXMLDialogDlg, Customer);


    //This is code created by App Wizard
    //{{AFX_DATA(CXMLDialogDlg) 
     CString     m_strCity;
     CString     m_strCountry;
     CString     m_strName;
     CString     m_strRichEditXML;
     //}}AFX_DATA 
}

// End XMLDialog.h 
////////////////////////////////////////////////////////////// 
  


///////////////////////////////////////////////////////////// 
// Begin XMLDialog.cpp 
IMPLEMENT_FACTORY(CXMLDialogDlg,          Customer)

void CXMLDialogDlg::MapXMLTagsToMembers()
{
     MapMember(&amp;m_strName,      "ContactName",           &amp;gC);
     MapMember(&amp;m_strCity,      "City",                  &amp;gC);
     MapMember(&amp;m_strCountry,   "Country",               &amp;gC);
     MapMember(&amp;m_lstOrders,    MyOrder::GetStaticTag(), &amp;gGListHandler, 0 );
}

void CXMLDialogDlg::OnBtnMakeXML() 
{
     UpdateData(TRUE); // pickup the changes from the GUI into the member variables 
     m_strRichEditXML = ToXML();  // create the new XML 
     UpdateData(FALSE);           // display the new XML in the edit box 
}

void CXMLDialogDlg::OnBtnLoadGUI() 
{
     FromXML(m_strRichEditXML);  // parse the XML into 'this' 
     UpdateData(FALSE);// update everything on the GUI that AppWizard has a DDX map for 


     // note:UpdateData() does not push the list of 'Orders'[m_lstOrders] into the  
     // ListCtrl. The simplest way is to iterate [m_lstOrders] that contains the  
     // 'Orders' after the call to FromXML() is complete. 
     // This shows you the complex, SAXish like, way that will add 'Order' objects  
     // to the GUI as they are added to [m_lstOrders] by the Object Factory during  
     // the call to FromXML(). This requires adding some code to this's constructor:  
     // ModifyObjectBehavior(SUBOBJECT_UPDATE_NOTIFY);  
     // This causes the XMLFoundation to call ObjectMessage(), as each "Order" gets 
     // it's data from the XML.  This Actually adds data to the GUI DURING THE 
     // PARSING PROCESS, as opposed to the 'simplest' way that will add the data  
     // into the CListCtrl AFTER the parsing process.  


}


// The <span class="highlight">Order object is yellow</span>, the complexity is CListCtrl, not the XMLFoundation. 
void *CXMLDialogDlg::ObjectMessage( int nCase, char *pzArg1, char *pzArg2, int nArg3, void *pArg4 )
{
     if(nCase == MSG_SUBOBJECT_UPDATE) 
     {
          <span class="highlight">MyOrder *pO</span> = (MyOrder *)pArg4;
          int nItemIndex = m_List.InsertItem(LVIF_TEXT|LVIF_PARAM, 0, <span class="highlight">pO-&amp;gt;m_strOrderDate</span>, 
                                                                     0, 0, 0, (long)pO);
          m_List.SetItemText(nItemIndex, 1, <span class="highlight">pO-&amp;gt;m_strShippedDate</span>);

          // uncomment this to see that we can generate XML subsets very easily 
          //AfxMessageBox( pO-&amp;gt;ToXML() ); // call base class method 
     }
     return 0;
}</pre>
<h2><a name="CORBA Objects">CORBA Objects</a></h2>
<p>The XMLFoundation was designed and built for CORBA before 
it ever added any support for MFC.  If you have a pre-existing CORBA system
that needs some XML tools you have come to the right place.  If you are
building a new CORBA system - this is best tool available for XML support.</p>
<p>If you have read this document all the way to this point then you 
will likely understand how the XMLFoundation works for CORBA by showing 
you this tiny piece of code:</p>
<pre lang="C++">class CustomerImpl : public virtual CustomerBOAImpl, public virtual XMLObject</pre>
<p>along with the IMPLEMENT_ORB_FACTORY() macro defined in XMLObject.h,  this is how CORBA can natively support the FromXML() and 
ToXML()  by using the XMLFoundation.  The Object Factory can instantiate your interface objects for you based on the XML.</p>
<p>CORBA implementations can be done in Java or C++.  The XMLFoundation 
supports both.  CORBA breaks down the language barrier allowing Java 
applications to easily, and natively deal with C++ objects.  This 
example details the creation of C++ CORBA objects - The Java 
implementation is nearly 
identical further blurring the lines between Java/C++ within the same 
project.</p>
<p>The C++ CORBA implementation will bridge into J2EE Application 
servers everywhere, it will work for any ORB 
but a few of the most popular ones have been tested, and the makefiles 
are included with the CORBA sample that ships with the XMLFoundation. 
The three makefiles included are for:</p>

<ul>
<li>Borland/Enterprise Studio - Visibroker</li>
<li>IONA/iPortal Enterprise - Orbix</li>
<li>BEA/Weblogic Enterprise - ObjectBroker (works great with Tuxedo implementations)</li>
</ul>
<p>This example extends the ORB to provide native XML accessors.  The 
sample CORBA application is based around 1 very simple object type. 
It has a unique integer we call a CustomerID and a string we call a 
CustomerName. Each customer may contain 0 to n references to another 
object of the same type 
as it's self, a MyCORBAObject.  This would model something like a list 
of Customers that were referred by 'this' customer.</p>
<h3>The IDL Looks Like This</h3>
<pre lang="C++">module ExCORBA
{
 interface MyCORBAObject
 {
  void getXMLState(out string s);
  void setXMLState(in string s);
  void setState(in string s, in long l);
  void addSubObject(in string s, in long l);
  void delSubObjects();
  MyCORBAObject getSubObjectIOR(in long l);
  void dumpState(out string s);
 };
};</pre>
<h3>Follow this 12 Step Program</h3>
<p>This is a very simple application.  The client application makes 12 
calls to the server.  Every even numbered call is exactly the same - it 
is 
a call to getXMLState() to see what's going on in the server.  The 
client obtains an initial IOR from a server serialized IOR upon server 
startup.</p>
<ol>
<li>Assign some state in a native CORBA call.  This is a typical CORBA 
data assignment operation.  Two values are set in the object.  The 
client
assigns two members on the server.  The code looks like this on the 
client:
<pre lang="C++">CustObject1-&gt;setState("Root",777);</pre>
</li><li>View the state of the object in XML.  This uses the XML 
accessor to return the state of the object.  The code looks like this on
 the client:</li>
<pre>CORBA::String_var s;
CustObject1-&gt;getXMLState(s);</pre>
<p>and looks like this on the server:</p>
<pre lang="C++">void ExCORBAImpl::getXMLState( CORBA::String_out s)
{ 
  const char *p = ToXML();
  s = CORBA::string_dup(p);
}</pre>
<p>and the result XML is this:</p>
<pre lang="xml">&lt;MyCORBAImpl&gt;
   &lt;CustomerID&gt;777&lt;/CustomerID&gt;
  &lt;CustomerName&gt;Root&lt;/CustomerName&gt;
&lt;/MyCORBAImpl&gt;</pre>
<p>The tag names are configured by the ExCORBAImpl object like this:</p>
<pre lang="C++">void  ExCORBAImpl::MapXMLTagsToMembers()
{
    MapMember(&amp;_nCustID, "CustomerID");
    MapMember(&amp;_strCustName, "CustomerName",&amp;gGenericStrHandler);
    MapMember(&amp;m_lstCMyImplObjs, "MyCORBAImpl",&amp;gGListHandler,0);
}</pre>
<li>Update the state of the object through XML.  Step 1 used a typical 
object accessor to assign the state.  Step 3 accomplishes the same 
through XML. 
The code on the client looks like this:</li>
<pre lang="C++">CustObject1-&gt;setXMLState("&lt;MyCorbaImpl&gt;&lt;CustomerName&gt;SuperUser&lt;/CustomerName&gt;
&lt;/MyCorbaImpl&gt;");</pre>
<p>On the server the code looks like this:</p>
<pre lang="C++">void ExCORBAImpl::setXMLState( const char* pzXML ) 
{
    FromXML( pzXML );
}</pre>
<li>View the modified object state in XML.  This is the exact same code (client and server) as Step 2.  We're calling <code>getXMLState()</code> again, 
and the result is:</li>
<pre lang="xml">&lt;MyCORBAImpl&gt;
   &lt;CustomerID&gt;777&lt;/CustomerID&gt;
   &lt;CustomerName&gt;SuperUser&lt;/CustomerName&gt;
&lt;/MyCORBAImpl&gt;</pre>
<li>Add CORBA Sub-Objects through XML.  Step 5 is a lot like step 3 where we updated the name "root" 
to "SuperUser" through an XML assignment.  This time we'll add an object reference. The client code looks like this:</li>
<pre lang="C++">CustObject1-&gt;setXMLState(
 "&lt;MyCORBAImpl&gt;" 
       "&lt;MyCORBAImpl&gt;"
             "&lt;CustomerID&gt;123&lt;/CustomerID&gt;" 
             "&lt;CustomerName&gt;Al Gore&lt;/CustomerName&gt;" 
       "&lt;/MyCORBAImpl&gt;"
       "&lt;MyCORBAImpl&gt;"
             "&lt;CustomerID&gt;456&lt;/CustomerID&gt;" 
             "&lt;CustomerName&gt;George Bush Jr.&lt;/CustomerName&gt;" 
       "&lt;/MyCORBAImpl&gt;"
 "&lt;/MyCORBAImpl&gt;");</pre>
<p>and this is the code on the server:</p>
<pre lang="C++">void ExCORBAImpl::setXMLState( const char* pzXML ) 
{
   FromXML( pzXML );
}</pre>
<li>(exactly like steps 2 &amp; 4) - View the object's XML state.</li>
<pre lang="xml">&lt;MyCORBAImpl&gt;
   &lt;CustomerID&gt;777&lt;/CustomerID&gt;
   &lt;CustomerName&gt;SuperUser&lt;/CustomerName&gt;
   &lt;MyCORBAImpl&gt;
 
&lt;CustomerID&gt;123&lt;/CustomerID&gt;
 
&lt;CustomerName&gt;Al Gore&lt;/CustomerName&gt;
   &lt;/MyCORBAImpl&gt;
   &lt;MyCORBAImpl&gt;
 
&lt;CustomerID&gt;456&lt;/CustomerID&gt;
 
&lt;CustomerName&gt;George Bush Jr.&lt;/CustomerName&gt;
   &lt;/MyCORBAImpl&gt;
&lt;/MyCORBAImpl&gt;</pre>
<li>Get a CORBA object reference for object instance 456.  On the client the code looks like this:</li>
<pre lang="C++">ExCORBA::MyCORBAObject_var CustObject2;
CustObject2 = CustObject1-&gt;getSubObjectIOR(456);</pre>
<p>and on the server we walk the list of objects and return the first one that matches the supplied CustomerID like this:</p>
<pre lang="C++">ExCORBA::MyCORBAObject_ptr ExCORBAImpl::getSubObjectIOR(CORBA::Long CustomerID)
{
  // create an iterator[it] for the [m_lstCMyImplObjs] list 
  GListIterator it(&amp;m_lstCMyImplObjs);
  while(it()) // while there is more in the list 
  {
       XMLObject *pO = (XMLObject *)it++; // get the next Customer Interface 
       ExCORBAImpl*pIO = (ExCORBAImpl*)pO-&gt;GetInterfaceObject(); // widen the pointer 
       
        // test for a match - Use a keyed datastructure in the real world 
        if (pIO-&gt;GetCustomerID() == CustomerID)  
       {
            // Return the CORBA Interface to the desired object 
              return pIO-&gt;_this();
            break;
       }
  }
  return 0;
}</pre>
<li>Exactly like steps (2, 4 &amp; 6) EXCEPT we are using the Object ref returned by step 7.</li>
<pre lang="xml">&lt;MyCORBAImpl&gt;
  &lt;CustomerID&gt;456&lt;/CustomerID&gt;
  &lt;CustomerName&gt;GeorgeBush Jr.&lt;/CustomerName&gt;
&lt;/MyCORBAImpl&gt;</pre>
<li>Add a Sub-Object without using XML.  In the same way we used a 
traditional member assignment in step 1, we can create a new object 
reference 
to demonstrate the two models seamlessly working together.  On the 
client:</li>
<pre lang="C++">CustObject1-&gt;addSubObject("Michelangelo",1475);</pre>
<p>and on the server the code looks like this:</p>
<pre lang="C++">void ExCORBAImpl::addSubObject( const char* s, CORBA::Long l )
{
   ExCORBAImpl *p = new ExCORBAImpl;
   p-&gt;_nCustID = l;
   p-&gt;_strCustName = s;
   m_lstCMyImplObjs.AddLast((XMLObject *)p);
}</pre>
<li> Get an object reference to the object created in step 9 and display it's state in XML.  This is the client code:</li>
<pre lang="C++">CustObject2 = CustObject1-&gt;getSubObjectIOR(1475); // exactly like step 7 
CustObject2-&gt;getXMLState(s); // like steps (2, 4, 6, and 8) using the new reference.</pre>
<p>and the result is:</p>
<pre lang="xml">&lt;MyCORBAImpl&gt;
  &lt;CustomerID&gt;1475&lt;/CustomerID&gt;
  &lt;CustomerName&gt;Michelangelo&lt;/CustomerName&gt;
&lt;/MyCORBAImpl&gt;</pre>
<li>Deleting Sub objects.  All objects, no matter how they were created,
 are destroyed the same.  The list contains both Factory created objects
 
and Objects created the tradional way.  Once again this shows how 
seamlessly the ORB fits together with the XMLFoundations's Object 
Factory. 
This the CORBA Implementation/Interface and XMLObject are all one in the
 same.  This cleans up the whole mess.</li>
<pre lang="C++">CustObject1-&gt;delSubObjects();</pre>
<p>on the server:</p>
<pre lang="C++">void ExCORBAImpl::delSubObjects() IT_THROW_DECL((CORBA::SystemException))
{
   GListIterator it(&amp;m_lstCMyImplObjs);
   while(it())
   {
         XMLObject *pO = (XMLObject *)it++;
         pO-&gt;DecRef();
   }
   m_lstCMyImplObjs.RemoveAll();
}</pre>
<li>To see that step 11 worked, view the XML state like we did in 2,4,6,8, &amp; 10.  Now all the contained objects are gone, and 
"SuperUser" is alone.</li>
<pre lang="xml">&lt;MyCORBAImpl&gt;
   &lt;CustomerID&gt;777&lt;/CustomerID&gt;
   &lt;CustomerName&gt;SuperUser&lt;/CustomerName&gt;
&lt;/MyCORBAImpl&gt;</pre>
</ol>
<h2><a name="COM Objects">COM Objects</a></h2>
<p>Create a basic ATL COM project with Visual Studio.</p>
<p>Visual Studio will write your IDL, and implementation header files.  The following code sample is 
the standard implementation header file with a few small additions (highlighted in yellow) required for XML support.</p>
<pre lang="C++">class ATL_NO_VTABLE CMyATLObj : 
public CComObjectRootEx&lt;CComSingleThreadModel&gt;,
public CComCoClass&lt;CMyATLObj, &amp;CLSID_MyATLObj&gt;,
public IDispatchImpl&lt;IMyATLObj, &amp;IID_IMyATLObj, &amp;LIBID_EXATLCOMLib&gt;,
public XMLObject
{
~CMyATLObj();
DECLARE_REGISTRY_RESOURCEID(IDR_MYATLOBJ)
DECLARE_PROTECT_FINAL_CONSTRUCT()
BEGIN_COM_MAP(CMyATLObj)
COM_INTERFACE_ENTRY(IMyATLObj)
COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

<span class="highlight">void</span> MapXMLTagsToMembers();

public:
<span class="highlight">DECLARE_FACTORY(CMyATLObj, Container)</span>
};</pre>
<p>In your implementation file you'll need to add the macro at a global scope and implement 
<code>MapXMLTagsToMembers()</code> to define the Object to XML mappings.  This example maps an integer, 
a string, and a list of COM objects.</p>
<pre lang="C++">void
CMyATLObj::MapXMLTagsToMembers()
{
   MapObjectID("CustomerID",1);
   MapMember(&amp;m_nInteger, "CustomerID");
   MapMember(&amp;m_strString, "CustomerName", &amp;gGenericStrHandler);
   MapMember(&amp;m_lstCMyATLObj, CMyATLObj::GetStaticTag(),
&amp;gGListHandler,0);
}</pre>
<p>In the ExATLCOM sample application several additional methods have been added to the COM Object.  Most notably 
<code>put_XMLState()</code> that has the ability to 
assign members variables and create COM objects when supplied well-formed XML as input.</p>
<pre lang="C++">STDMETHODIMP
CMyATLObj::put_XMLState(BSTR newVal)
{
     _bstr_t b(newVal);
     FromXML((const char *)b);
     return S_OK;
}</pre>
<h2><a name="Object Caching and Instance Management">Object Caching and Instance Management</a></h2>
<p>XMLFoundation has been serving up the XML related needs of the 
application layer for nearly a decade.  It has been used to build a 
wide variety of application types.  A common recurring need in the 
application layer has to do with "data updates".  Any application 
that receives XML updates might consider the performance advantages and 
reduction in development labor by using the XMLFoundation to solve the 
problem for them.</p>
<p>For example, suppose you had some large dump of XML data.  In your 
application layer you need to quickly access individual 
pieces of that information.  In just a few lines of code, the XML can be
 mapped to a keyed data structure for fast indexed reads by your 
application.  If the initial 
XML dataset was 100+million records - you will want to provide updates 
to your indexed information rather than rebuilding the entire index.  
You could 
write the code to search for the data to update, or allow the 
XMLFoundation to manage it for you.</p>
<p>Another common example in distributed systems: Data is often cached at a middle tier or in the application itself. 
Efficiently designed systems only update an "Address" rather than a whole "Customer" and all his "Orders" when an 
"Address" changes.  XMLFoundation can greatly simplify this task.</p>
<p>At the core of caching is something XMLFoundation calls the OID, or 
Object ID.  It is a unique key to the object, and any object that 
participates in XMLFoundation caching must have one.  The definition of 
the OID can come from 2 places.  It can be defined in the XML data, or 
it can 
be defined by the object that mapped the data.</p>
<p>This is how a "'<code>MyOrderLineItem</code>" object might define the
 OID.  It uses a combination of the "ProductID" and 
"UnitPrice" so in this example a price change constitutes a different 
object.  Normally an OID has a direct correlation to DBMS indexes in 
properly <a href="http://www.agiledata.org/essays/dataNormalization.html">normalized data</a>.  ObjectID's can be made to work well over poor data models 
too.  This example code uses two XML Elements ("ProductID" and "UnitPrice") to build the unique object ID. 
<code>MapObjectID()</code> also allows you to use Attributes to define the OID.</p>
<pre lang="C++">void MyOrderLineItem::MapXMLTagsToMembers()
{
     MapObjectID("ProductID",1,"UnitPrice",1);
}</pre>
<p>Alternatively the OID can be directly defined by the data itself with
 a special attribute named "OID" - so that NO CODE needs to be written.</p>
<pre lang="xml">&lt;MyOrderLineItem oid='777'&gt;
     &lt;ProductID&gt;123&lt;/ProductID&gt;
     &lt;UnitPrice&gt;7.77&lt;/UnitPrice&gt;
&lt;/MyOrderLineItem&gt;</pre>
<p>The sample application "ObjectCache" provides over 30 test cases that detail the usage of object caching.</p>
<h2><a name="Parsed And Unparsed">Parsed and Unparsed Object Data</a> </h2>
<p>For the most part - objects contain members.  Members are mapped to 
attributes and elements in the XML.  For the most part - that is how 
most 
XML documents are arranged but as you will see here there are yet still 
two other forms of markup for getting untagged data into the object. 
As a prerequisite to reading the following paragraph you must know a 
little bit about what the XML specification refers to as CDATA, so go 
plug that into your 
favorite search engine if you are not familiar with unparsed data then 
when you pop your stack of things to do you will find yourself ready to 
continue reading this:</p>
<pre lang="xml">&lt;Thing Color='Red White and Blue'&gt;

     &lt;![CDATA[&lt;data&gt;x&lt;/data&gt;]]&gt;-Object Data-=            
&lt;---Pay special attention to this line

     &lt;String&gt;Capitol Capital G&lt;/String&gt;

     &lt;Number&gt;777&lt;/Number&gt;

     &lt;Wrapper&gt;
              &lt;StringList&gt;one&lt;/StringList&gt;
              &lt;StringList&gt;two&lt;/StringList&gt;
     &lt;/Wrapper&gt;=-More Object Data- 
&lt;---and this line  (Parsed Data)

&lt;/Thing&gt;</pre>
<p>The class declaration below has Maps for all of the elements and attributes in the XML above.  
It makes no provisions for Object Data - Parsed   or  Unparsed.</p>
<pre lang="C++">class MyCustomObject : public XMLObject
{
public:

     GString m_strString; // A String Member
     GString m_strColor; // An attribute , not an element
     int m_nInteger; // An Integer Member
     GStringList m_strList; // A String List


virtual void MapXMLTagsToMembers()
{
     MapMember( &amp;m_strList, "StringList", "Wrapper");
     MapMember( &amp;m_nInteger, "Number");
     MapMember( &amp;m_strString, "String");
     MapAttribute(&amp;m_strColor, "Color");
}

DECLARE_FACTORY(MyCustomObject, Thing) 

MyCustomObject(){} 

    ~MyCustomObject(){};

};

IMPLEMENT_FACTORY(MyCustomObject, Thing)</pre>
<p>This is how your code will obtain this "unmapped" object data.</p>
<pre lang="C++">void ObjectDataAndCDataExample()
{
    MyCustomObject O;
    O.FromXMLX(pzXML);

    GString *pG = O.GetCDataStorage();
    printf(*pG); // prints out "&lt;data&gt;x&lt;/data&gt;"
    printf("\n\n"); 

    // Notice that the memory address of the (unparsed)CDATA start is 43 bytes past &amp;pzXML[0]
    // This CDATA buffer will always be in the original memory, not a copy of that buffer.
    // This unparsed data from the XML is handed directly to the application layer.
    int nOffsetFromStartofXML = pG-&gt;Buf() - pzXML; // nOffsetFromStartofXML is 43


    pG = O.GetObjectDataStorage();
    // you can see by this offset that we are in a different memory region now 
    // (because the fragmented Object data is now contigous)
    nOffsetFromStartofXML = pG-&gt;Buf() - pzXML; // nOffsetFromStartofXML is way out there.
    printf(*pG); // prints out "-Object Data-==-More Object Data-"
    printf("\n\n");

    // notice that the 'normal' data mapped to String, StringList, and Int 
    // are in the members and data structures where they have been mapped to.
    // Notice how the Object Data is rearranged in the output to a lexically equal notation.
    // Also notice that no whitespace (carriage returns or tabs) can be used to beautify this ugly Object Data
    // or it would alter the data, unlike the whitespace added between XML element tags to beautify them.
    // If Object Data has a Carriage Return in it, that is part of the data.
    printf(O.ToXML());
    printf("\n\n");

/*

&lt;Thing Color="Red White and Blue"&gt;
     &lt;![CDATA[&lt;data&gt;x&lt;/data&gt;]]&gt;-Object Data-==-More Object Data-
     &lt;Wrapper&gt;
          &lt;StringList&gt;one&lt;/StringList&gt;
          &lt;StringList&gt;two&lt;/StringList&gt;
     &lt;/Wrapper&gt;
     &lt;Number&gt;777&lt;/Number&gt;
     &lt;String&gt;Words&lt;/String&gt;
&lt;/Thing&gt;

*/
// ------------------------------

// now inversely, from a fresh object O2, make the xml
MyCustomObject O2;
O2.m_nInteger = 777;
O2.m_strString = "G.G.G.Guru";
O2.m_strColor = "Gold, Green and White";

*(O2.GetCDataStorage()) &lt;&lt; "x&lt;data&gt;x";
// notice how this CData is not parsed

O2.SetObjectDataValue("-- object &lt;data&gt; is parsed --");         
//  and how the object data is parsed
// when they are turned into XML
printf(O2.ToXML());


/* // it looks like this:
&lt;Thing Color="Gold, Green and White"&gt; 
     &lt;![CDATA[x&lt;data&gt;x]]&gt;-- object &amp;#60;data&amp;#62; is parsed -- 
     &lt;Number&gt;777&lt;/Number&gt;
     &lt;String&gt;G.G.G.Guru&lt;/String&gt;
&lt;/Thing&gt;

*/

}</pre>
<h2><a name="FiveLoaves">FiveLoaves</a> (aka ServerCore)</h2>
<p>5Loaves is included with the XMLFoundation, but not in the foundation. 
It is a tool that uses XMLFoundation.  It needs the XMLFoundation but the
XMLFoundation does not need 5Loaves.  5Loaves is implemented in a single
file called ServerCore.cpp.  It is a unique piece of code and it is very simple to use.  There is no
header file for ServerCore.cpp and it causes no DLL's to be loaded by your application. 
It is a portable, properly threaded, and well written server core that can be
applied to countless custom server implementations.  It is a Proxy. 
It is an HTTP Server.  It is a 'connection joiner'.  ServerCore.cpp is
currently used to accept TCP connections for an advanced networking 
<a href="http://cid-d7ec275e76d295cf.skydrive.live.com/self.aspx/Software/Xfer%20Eval.zip">product called Xfer</a>. (note: Xfer is not open
source).  The ServerCore has a good portable threading
model with some unique features that allow you to limit such things as, number
of connections per IP/Subnet and Connections per second.  The 5Loaves HTTP
Server works faster than IIS or Apache in some cases.  It has been designed to be fast and includes unique features such as
'content caching' to serve up prebuilt HTTP headers and data from memory rather
than from disk.</p><p>The Core of 5Loaves is a ground up POSIX threaded TCP server.  This
server template can be applied to build many types of applications that service
TCP connections.  The sample programs are server applications that use the
5Loaves ServerCore.  One example is the 5Loaves shell console.  It is
a command line interpreter like the DOS prompt or a Unix shell written from
scratch.  It is a useful application starting point if you ever need a
simple shell that has been tested in Linux, Solaris, AIX, HPUX, and
Windows.  There is also a Windows Service application.  It contains
the proper implementation for integrating 5Loaves with the Windows Service
Control Manager.  There is also an example program with all the source to
an ActiveX implementation of 5Loaves so you can see that this server core can be
embed just about anywhere in any development language.</p><p>The following code sample shows you how to start the HTTP service from inside
your own process.  You can't do that with IIS or Apache.  The HTTP
server does support binary plugins like ISAPI, and there is an example program
that creates plugins.  It's an advanced HTTP server.</p><pre lang="C++">// This is a complete source example to embed a solid and high performance
// HTTP Server in your application that starts on a variable port with a
// variable home directory.
#include "../Core/ServerCore.cpp"


char *pzBoundStartupConfig =
"[System]\r\n"                // &lt;-- notice the [System] section
"Pool=20\r\n"
"ProxyPool=0\r\n"
"\r\n"
"[HTTP]\r\n"                // &lt;-- notice the [HTTP] section
"Enable=yes\r\n"
"Index=Index.html\r\n"
"Home=%s\r\n"
"Port=%s\r\n";

void CMyClass::StartHTTPServer(const char *pzHomeDirectory,const char *pzPort)
{
     // Fill the two variables into the startup config string
     GString strCfgData;
     strCfgData.Format(pzBoundStartupConfig,pzHomeDirectory,pzPort);
          
     // Set the global profile object
     SetProfile(new GProfile( strCfgData, strCfgData.Length()) );
     
     // Start the HTTP service
     server_start();</pre><h2>Building a Custom HTTP Web Service</h2><p>Approach #1 - "Low Level Static Code"</p><p>Adding on to the rather trivial amount of code shown above for integrating
ServerCore, you may want to develop
a custom "dynamic content" server based on this HTTP server
implementation that can be easily integrated into YOUR process (unlike IIS or
Apache).  There are several ways to go about accomplishing this task and
depending on your situation one way may be more appropriate than another. 
One way of implementing a custom ServerCore extension can be accomplished via
"Low Level Static Code".  The advantage to this form of
integration is that no DLL's are loaded. Another possible advantage is that no
form of integration could possibly be faster.  Using this approach ServerCore will manage nothing except for multi-threading
the connections for you and the initial TCP network read.</p><p>This can be done by adding this one line of code:</p><pre lang="C++">#define SERVERCORE_CUSTOM_HTTP</pre><p>prior to adding this line of code:</p><pre lang="C++"> #include "../Core/ServerCore.cpp"</pre><p>You will also have to create a file called ServerCoreCustomHTTP.cpp, a
sample implementation has been provided in the Server/Core folder.  To see it work in the
"5Loaves" example project add the #define SERVERCORE_CUSTOM_HTTP into the file Servers/5loaves/Console.cpp then create a
text file called 5Loaves.txt that you can place in the same folder as the binary
or at "C:\\" with this contents.</p><pre lang="text">[System]
Pool=20
ProxyPool=0


[HTTP]
Enable=yes</pre><p>This sets the thread pool to 20 setting the limit of 
your server to 20 concurrent client connections and supports no proxy 
connections, you may set the 
thread pool at any value that you have enough hardware resources to 
support.</p><p>Making this example work in the Windows Service is equally as simple by adding  #define SERVERCORE_CUSTOM_HTTP 
into Servers/WebServerService/WebServerService.cpp (directly above the inclusion of ServerCore.cpp) This will extend 
the service application to run a custom 'low level - static code' extension that is implemented in <em>ServerCoreCustomHTTP.cpp</em> 
exactly like the console application.</p><p>I have two products that 
both use this "Low Level Static Code" approach to extending 
ServerCore.cpp.  It is my preferred approach when
building an "application" based on ServerCore.cpp because the 
integration is "tight" beyond the definition 
of "tight".  You should search <em>ServerCore.cpp</em> for 
SERVERCORE_CUSTOM_HTTP to see for yourself that this is not function 
call - but a true inline implementation into the very first call stack 
frame of the servicing thread.  Since the code is being added directly 
into the lowest level possible there is no function call dispatch, it 
executes the extension without even adding a new frame on the call stack
 
(you can't do that with IIS or Apache - much less in YOUR process space)
 - this makes the extension code look strange because there will 
be no open scope { or close of scope } - and you will exit with a GOTO 
rather than a return.  For example consider this complete 
example found in <em>Servers/Core/ServerCoreCustomHTTP.cpp</em>:</p><pre lang="C++">//
// Server Core Extension Example for when SERVERCORE_CUSTOM_HTTP is defined in ServerCore.cpp
//

// There are many variables available to the current scope.  A few of exceptional interest are:
// [td-&gt;sockfd] the socket handle
// [sockBuffer] the raw network data directly in the TCP kernel buffer
// [nContentLen] the Content-Length from the HTTP header
// [nBytes] bytes in [sockBuffer] (note there may be more in transit if Content-Length &gt; nBytes )
if (memcmp(sockBuffer,"GET",3) == 0)
{
   
     GString strRequest;
     // extract the file name starting at the 4th byte up to the first space
     // Proper HTTP will look like this:GET /Index.html HTTP/1.1
     strRequest.SetFromUpTo(&amp;sockBuffer[4]," ");

     // now you have the request in the variable [strRequest]

     // you need to generate a response for yourself based on the request.
     // This is a good place to dispatch your call to your own functions
     // You might return HTML, or XML
     GString strResponse("Server Response: Hello World");
   
     // since we did not build any custom HTTP headers we'll send the response back through HTTPSend()
     // This will build the HTTP headers for us setting the Content-Length - required for valid HTTP.
     HTTPSend(td-&gt;sockfd, strResponse, strResponse.Length());

     // alternatively we could setup the HTTP header ourselves and call nonblocksend()
     // int nonblocksend(int fd,const char *pData,int nDataLen)

     // lastly - manage this connection and thread.
     // this will read the next HTTP command from this connection - on this thread
     goto KEEP_ALIVE;

     // alternatively we could close this connection and return this thread to the pool
     // nCloseCode = 7000;
     // goto SOCKET_ERR_ABORT;

}
else if (memcmp(sockBuffer,"POST /",6) == 0)
{
     // likewise the same ideals apply for a POST handler
}</pre><p>Now - to see this example work... Run 5Loaves.exe with the 5Loaves.txt in the same directory 
Put this URL into your browser:   http://127.0.0.1/ Your browser will display "Server Response: Hello World"</p><p>Approach #2 - "Binary Plugin"</p><p>This
 next approach to extending an HTTP service is more typical.  Both IIS 
and Apache support both CGI and ISAPI to support user developed web 
server 
extensions via "Binary Plugin's".  This approach allows you to rebuild 
the extension without rebuilding the HTTP server.  You will create 
a DLL (under Windows) or an SO (under Unix) that works a lot like ISAPI.
 The HTTP service will load and execute your extension giving you access
 to 
everything necessary to build any kind of custom extension.  The 
ServerCore adds one additional layer of abstraction by invoking the 
"Plugin" 
through the "Language Driver" described in the next section.</p><h2><a name="Plugins">Plugins</a>  and Language Drivers</h2><p>The XMLFoundation supports "Language Drivers".  5Loaves is
among the applications that implements them.   Language
drivers allow user developed extensions to be invoked programmatically. 
Just about every programming language can have a language driver developed for
it.  Several complete Language Driver implementations come with the XMLFoundation
source code.</p><p>The programmer's code is "the plugin"
that is executed by the "Language Driver".  The majority of
people who use this technology will probably be developing "plugins", but you
also may develop an application that allows users to develop their own plugins. 
All of the source
code for everything I speak of is included in the XMLFoundation, see [IntegrationBase.h/cpp][IntegrationLanguages.h/cpp],
using DynamicLibrary.h to load the DLL/SO's on many platforms.</p><p>I have used the Language Driver functionality in several
applications.  For example, I have an XSLT that allows user extensions in
addition to the built-in XSL keywords.  This allows my application to pass a
string value into a user defined method in a plugin that might need to do a
database lookup to translate a code - a task that is too complex for any XSL
keyword.  Loading the "Language Driver" and executing a plugin
does not require much code.  This is the code to pack 4 arguments and
invoke a plugin called "Test1" inside "PluginExample.dll"
through the CStdCall Language Driver:</p><pre lang="C++">// pack 4 arguments -- same code to call (C++/Java/COM/Perl/Python) plugins
 // 1. a 4 bytes string ("aaa" + null)
 // 2. a 4 byte string  ("bbb" + null)
 // 3. a 4 byte unsigned long (the .... starts at the 8th byte and will be overwritten)
 // 4. a 5 byte string  ("fast" + null)
 char pzArgBuff[256];
 sprintf(pzArgBuff,"aaa%cbbb%c....fast%c",0,0,0);  // the .... is a 4 byte placeholder
 unsigned long *pL = (unsigned long *)&amp;pzArgBuff[8]; // get an int pointer to the 8th byte
 *pL = 777;     // overwrite the (....) with the packed binary value for 777
 char pzArgSizes[16];
 strcpy(pzArgSizes,"4|4|4|5");

 // Invoke the plugin....
 InterfaceInstance *pII = GetInterfaceInstance("CStdCall");
 // InvokeEx may modify the pzArgBuff, but generally results should be in pzResults
 int nOutResultSize;
 const char *pzResults = pII-&gt;InvokeEx( "PluginExample.dll", "PluginExample", "Test1",
                                           pzArgBuff,pzArgSizes,&amp;nOutResultSize, "anonymous",
                                           "password" );</pre><p>The code shown above would be in the hosting application, or the application that supports custom extensions. 
It will then execute the plugin that is even easier to develop (code shown below):</p><pre lang="C++">ExposedMethods() should define the arguments like this:
Test1&amp;&amp;One&amp;&amp;char *&amp;&amp;Two&amp;&amp;char  *&amp;&amp;Three&amp;&amp;Packed Unsigned Long&amp;&amp;Four&amp;&amp;char *
extern "C" __declspec(dllexport) void Test1(void *pHandle, DriverExec Exec,
                                                const char *One,     // string "aaa"
                                              const char *Two,     // string "bbb"
                                              const char *Three,   // unsigned long
                                              const char *Four)    // string "fast"

{
     PlugInController PIC(pHandle, Exec);

     // dereference Three and increment it by one, this changes
     // the argument value in the callers memory space in the application -
     // (pzArgBuf above setting *pL to 778)
     // The direct memory reference is passed into the language driver -
     // then passed into this DLL/SO
     (*(unsigned long *)Three)++;

     // If you want to modify the argument Three locally use this code:
      unsigned long uThree = *(unsigned long *)Three);
      uThree++;
      PIC.AppendResults("Argument 3 is Native Packed Binary in a Plugin");
}</pre><p>One sample application titled "PluginExample" is devoted to 
C++ plugins.  It shows how to write several types of POST handler 
plugins for 
the HTTP server.  You will find the utility class CMultiPartForm handy 
if you need to write a handler for a Multipart HTTP POST, other plugin 
utilities 
like PlugInController found in PluginBuilder.h make the job of building a
 plugin as easy as possible.</p><p>ServerCore.cpp has the implementation
 using (InterfaceInstance *)pII-&gt;InvokeEx()described above already 
complete so that you 
may extend the HTTP service via your own DLL(or COM object or 
Perl/Python script).  This is how to build a custom dynamic web page 
from an HTTP server plugin:</p><ol>
<li>Compile the CStdCall Language Driver
 
 

</li><li>Compile the PluginExample
 
 
</li><li> Setup
the 5Loaves.txt Configuration File like this (but set the [TXML]Drivers=
and [CStdCall]Path= to where steps 1 and 2 compiled to):

 
 
<pre lang="text">[System]
Pool=20
ProxyPool=0

[HTTP]
Enable=yes
EnableServerExtensions=yes
ServerPlugin1=/Test2WWWPage|CStdCall|PluginExample.dll|PluginExample|Test2
ServerPlugin2=/Test3WWWPage|CStdCall|PluginExample.dll|PluginExample|Test3
ServerPlugin3=/Test4WWWPage|CStdCall|PluginExample.dll|PluginExample|Test4
ServerPlugin4=/Test5WWWPage|CStdCall|PluginExample.dll|PluginExample|Test5
ServerPlugin5=/Test7WWWPage|CStdCall|PluginExample.dll|PluginExample|Test7
ServerPlugin6=/Page1|CStdCall|PluginExample.dll|PluginExample|Page1
ServerPlugin7=/Page2|CStdCall|PluginExample.dll|PluginExample|Page2
ServerPlugin8=/Page3|CStdCall|PluginExample.dll|PluginExample|Page3

[TXML]
Drivers=C:\XMLFoundation\Drivers\Debug

[CStdCall]
Path=C:\XMLFoundation\Examples\C++\HTTP.Xfer.Messaging-PluginExample</pre><p>The HTTP service will loop through the ServerPluginN entries and dispatch the
plugin calls for you.  You must configure the ServerPluginN entries in
numerical order and the HTTP service will load each entry upto the first
numerical break.  You may also manage the dispatch partially yourself by
using a wildcard * in the first argument - for example.</p><pre>ServerPlugin1=/PluginPage*|CStdCall|MyDLL.dll|MyDLL|DoIt</pre><p>This would map the following URL's to DoIt() in:</p><pre lang="text">MyDLL.dll
http://127.0.0.1/PluginPageFoo.html
http://127.0.0.1/PluginPageBar%20Argument1%20Argument2
http://127.0.0.1/PluginPageHello</pre></li><li>Put
the 5Loaves.txt file into the project directory if you run 5Loaves.exe under a
debugger or put 5Loaves.txt in the same directory as 5Loaves.exe if you run
5Loaves.exe outside the debugger - either way when it starts 5Loaves will
display this message:</li>
 

 
<pre lang="text">5Loaves&gt;Windows Console using [5Loaves.txt]
Listening on port[80]
All bound ports are now being serviced
started

5Loaves&gt;</pre><li>Now
execute the most basic plugin that takes 0 arguments and is simply a static
bound html page - put this URL into your browser: http://127.0.0.1/Page1</li>
 
<p>The browser will show a simple web page with 3 edit fields and a
"Submit" button.    If you see that page - the plugin
executed properly through an HTTP GET which loaded an HTML page that will POST
back the 3 arguments into another handler that exists in that same plugin. 
The information POST'ed by the HTML form calls a method with with 3
arguments.  So you supply the values 1, 2, and 3 to the three edit fields
and press submit your browser will display this:</p><pre lang="text">5Loaves HTTP Server Invoked me with [1] and [2] and [3]!</pre><li>Now try this URL: <em>http://127.0.0.1/test2WWWPage&amp;root&amp;777&amp;superuser</em> and this will be the result:</li>
<pre lang="text">5Loaves HTTP Server Invoked me with [root] and [777] and [superuser]!</pre><li>Look at the Plugin example to see the details of implementing a plugin. 
You will see that this is the plugin handler that was called in step 5 and 6:</li>
<pre lang="C++">extern "C" __declspec(dllexport) void Test2(void *pHandle, DriverExec Exec,
                                                      const char *One,     // string
                                                       const char *Two,    // string
                                                       const char *Three)  // string

{
     PlugInController PIC(pHandle, Exec);
   
     // build the string "5Loaves Invoked me with [root] and [777] and [superuser]!"

     PIC.AppendResults("5Loaves HTTP Server Invoked me with [");
     PIC.AppendResults(One);
     PIC.AppendResults("] and [");
     PIC.AppendResults(Two);
     PIC.AppendResults("] and [");
     PIC.AppendResults(Three);
     PIC.AppendResults("]!");
}</pre></ol><h2><a name="FiveLoaves Tunneling">FiveLoaves Tunneling</a> and
Messaging</h2><p>5Loaves provides tunneling with encryption and compression as a base
service.  It can be used to secure internet connections much like SSH. 
It works by running some form of server with the 5Loaves engine on two
machines.  The data passed between those machines can be compressed or
encrypted or simply logged.  Starting the server is done exactly the same
no matter if you are running the HTTP service or the Tunneling service - only
the configuration startup string changes.  The following configuration
example will open a listener on port 1972, anything it receives will be
encrypted and compressed and sent to [www.ExampleServer.com] on port 2009. 
The server will decrypt and decompress the data from port 2009 and forward it to
port 1972, so the data on port 1972 at the server will be as if the client had
directly sent it.  To open a tunnel entry point on the client side use
this:</p><pre lang="text">[Tunnel1]
Enable=yes
LocalPort=1972
RemotePort=2009
RemoteMachine=www.ExampleServer.com
Timeout=30
CompressEnabled=yes
CipherPass=Tiger
RawPacketProxy=no</pre><p>To exit the tunnel on the server:</p><pre lang="text">[Proxy1]
Enable=yes
LocalPort=2009
RemotePort=1972
RemoteMachine=127.0.0.1  (we could also use an internal resource like
192.168.*)
Timeout=60
RawPacketProxy=no
CompressEnabled=yes
CipherPass=Tiger</pre><p>Note: you can start any number of tunnels, simply increment the section
[Tunnel2] and [Proxy2].  ServerCore will stop loading tunnels at the first
break of numeric order of the [sectionN].</p><p>This type of usage may be of
interest especially to web developers or people who are just curious. 
Sometimes it's interesting to see the data between the HTTP server and the
browser.  Redirects and HTML frames and Javascript can make that difficult. 
This section sets up a clear text proxy just for the purpose of seeing the
transmission log between the browser and the web-server.  Once this is
running, connect with a web browser to 127.0.0.1 and you in fact be
connecting to the endpoint configured under the RemoteMachine= entry.</p><pre>[Tunnel2]
Enable=yes
LocalPort=80
RemotePort=80
RemoteMachine=www.SampleWebSite.com
Timeout=65000
RawPacketProxy=yes
LogPath=c:\HTMLSpy
LogBinary=no
LogEnabled=yes</pre><p>In the folder HTMLSpy you will see a log file of the communication between
the browser and the web server.  I used Firefox as a browser, and the
5Loaves HTTP server for this example.  I loaded the page twice in the
browser so that you can see the caching mechanism working between the browser
and the web server in this log file:  The header is defined like this:
"tx-&gt;s" means "transmit to server" so that is information
that came from the browser, it is followed by the time, then the total bytes
transmitted, 470 in this case.  The reply is "tx-&gt;c" or
"transmit to client", you can see that the HTTP server responded with
181 bytes that instructed the browser to use the version it has cached. 
You can also see that the "Server:" name was set to "MyWebServer",
that is a variable in the 5Loaves HTTP server unlike the static names IIS and
Apache use.</p><pre>tx-&gt;s00:51:42-000470&gt;
GET / HTTP/1.1
Host: 127.0.0.1
User-Agent: Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US; rv:1.9.0.11)
Gecko/2009060215 Firefox/3.0.11
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-us,en;q=0.5
Accept-Encoding: gzip,deflate
Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7
Keep-Alive: 300
Connection: keep-alive
If-Modified-Since: Thu, 01 Jan 1970 00:00:00 GMT
If-None-Match: 7430174881
Cache-Control: max-age=0


tx-&gt;c00:51:42-000181&gt;
HTTP/1.1 304 Not Modified
Server: MyWebServer
Date: Sun, 16 Aug 2009 07:01:12 GMT
Connection: keep-alive
Keep-Alive: timeout=20, max=149
ETag: 7430174881
Content-Length: 0</pre><p>By changing the log binary to yes, now we can see what a small gif file looks
like over the wire from the web server.</p><pre>[Tunnel2]
LogBinary=yes

tx-&gt;c01:05:29-000317&gt;
48 54 54 50 2F 31 2E 31 20 32 30 30 20 4F 4B 0D 0A 44 61 74 65 3A 20 57
65      HTTP/1.1 200 OK..Date: We
64 2C 20 30 31 20 4A 75 6C 20 32 30 30 39 20 30 31 3A 30 35 3A 32 39 20
47      d, 01 Jul 2009 01:05:29 G
4D 54 0D 0A 53 65 72 76 65 72 3A 20 4D 79 57 65 62 53 65 72 76 65 72 0D
0A      MT..Server: MyWebServer..
43 6F 6E 6E 65 63 74 69 6F 6E 3A 20 6B 65 65 70 2D 61 6C 69 76 65 0D 0A
4B      Connection: keep-alive..K
65 65 70 2D 41 6C 69 76 65 3A 20 74 69 6D 65 6F 75 74 3D 32 30 2C 20 6D
61      eep-Alive: timeout=20, ma
78 3D 31 34 39 0D 0A 4C 61 73 74 2D 6D 6F 64 69 66 69 65 64 3A 20 53 75
6E      x=149..Last-modified: Sun
2C 20 31 33 20 4D 61 72 20 32 30 30 35 20 32 32 3A 33 32 3A 33 36 20 47
4D      , 13 Mar 2005 22:32:36 GM
54 0D 0A 45 54 61 67 3A 20 31 31 31 30 37 34 39 35 35 36 0D 0A 43 6F 6E
74      T..ETag: 1110749556..Cont
65 6E 74 2D 74 79 70 65 3A 20 69 6D 61 67 65 2F 67 69 66 0D 0A 43 6F 6E
74      ent-type: image/gif..Cont
65 6E 74 2D 6C 65 6E 67 74 68 3A 20 37 34 0D 0A 0D 0A 47 49 46 38 39 61
10      ent-length: 74....GIF89a.
00 10 00 91 00 00 00 00 00 FF FF FF FF FF FF 00 00 00 21 F9 04 01 00 00
02      ..................!......
00 2C 00 00 00 00 10 00 10 00 00 02 1B 94 8F A9 CB 07 AD C0 83 4E 52 23
2D      .,...................NR#-
CD BA F1 BE 7C 5B 76 91 E5 54 5E EA CA 1A 05 00
3B                           
....|[v..T^.....;</pre><h2>Messaging</h2><p>5loaves has a unique network connectivity utility built in.  It allows 
machines behind a firewall that cannot "listen" for connections
outside the network to accept connections from anywhere without any firewall
configuration changes.  There is a complete example called "FilePoster"
that puts a file on a machine behind a firewall.  This is a bare bones
'proof of concept' implementation that gives you a working model to customize
for your own purposes.  It requires 3 machines to see it work as designed.</p><p><strong>Machine 1 </strong>- (the switchboard) should be located on the
internet.  You must run the HTTP service along with the "Switchboard
Service", you can see that this example runs it on port 81 just incase you
have IIS or Apache already on port 80.</p><pre lang="text">[SwitchBoardServer]
Enable=yes
Name=/PublicPath/

[HTTP]
Enable=yes
Port=81
ContentCache=0
UseKeepAlives=1
HTTPHeaderServerName=5Loaves
KeepAliveTimeOut=20
ShowIPAddressPageName=ShowIP
Home=d:\home


[Trace]
HTTPHeaderTrace=0
ThreadTrace=0
ConnectTrace=1</pre><p><strong>Machine 2 </strong>- (the server) this is the machine behind the
firewall that you want to open up a connection path to.  It will poll the
switchboard server looking for connections.  It should run 5oaves with the
configuration below.  This will accept remote data, and write it to disk in
a file at "c:\5LMessages\UBTsAccountForYou".  You could change
the application logic that writes the file - you can do anything with the data
that may contain commands, database queries, or custom logic.</p><pre lang="text">[Messaging]
Enable=yes
AcceptFrom=UBTsAccountForYou
DefaultSwitchBoardServer=10.20.30.40
DefaultSwitchBoardPort=81
UseBrowserProxy=no


[MsgFrom-UBTsAccountForYou]
Enable=yes
CheckAtSwitchBoard=yes
Name=/PublicPath/UBTsAccountForYou
DiskLocation=c:\5LMessages\UBTsAccountForYou
LetSenderPlaceFile=No
PollIntervalSeconds=20</pre><p><strong>Machine 3</strong>- (the client) 
runs the FilePoster sample application.  Machine 3 can reach "the 
switchboard (machine 1)" 
but not "the server (machine 2)".  We will send the data to Machine 2 
and get a response back from that machine.  In this case we are 
simply writing the data we send to a file, but the data could just as 
easily have been an SQL statement and the return data could be the 
result set rather 
than just a confirmation that the file was written.</p><p>How it works:</p><p>The
 "server" polls into the "switchboard" with an HTTP GET.  The "client" 
pushes a multipart HTTP POST to the 
"switchboard".   The switchboard joins the connections and proxies the 
data.  An HTTP GET needs an HTTP  "200 OK" so the 
"switchboard" server rips off the POST headers from the data sent up by 
the "client" and replaces them with an HTTP 200 followed by the 
POST data that gets proxied straight through.  Once this initial message
 proxy is complete, the client connection that POSTed it 
waits in the switchboard, for the server to POST back a response.  Then 
the Switchboard goes through the same process of ripping off the POST 
HTTP header and replacing it with a 200 OK 
before sending the response back to the client.  Lastly, the switchboard
 server replies with an empty HTTP 200 to the servers response POST to 
complete the normal HTTP request/response 
design for both the client and the server.  This allows it to pass 
through HTTP proxy servers and direct support for them is included.  
Technically 
this is a loophole through most networks that only allow HTTP, because 
as you see we invented a new protocol that looks like HTTP, but in fact 
it is not.</p>
<p>&nbsp;</p>
<p>&nbsp;</p><h2><a name="Mapping XML to Bits of a Byte">Mapping XML to Bits of a Byte</a></h2>
<p>There is little need for an English description for how to map bits of a 
member variable using this method found in xmlObject.h</p>
<pre lang="cs"><font color="#008000">// Map bits within a 8,16,32, or 64 bit space.
// nBit1toN is a 1 based index value of the bit within pValue
// pzCommaSeparated0Values might be &quot;No,OFF,0,false&quot; if you want those case insensitive values (False==FALSE==false) to set the bit to 0
// since &quot;No&quot; is first in the list, that will be used to indicate the bit is 0 when creating the xml.
// pzCommaSeparated1Values might be &quot;Yes,On,1,True&quot; if you want those case insensitive (YES==Yes==yes) values to set the bit to 1
// since &quot;Yes&quot; is first in the list, that will be used to indicate the bit is 1 when creating the xml.
// The lists are parsed, and cached, during the first call to MapXMLTagsToMembers()
</font>void MapMemberBit(<font color="#000080">unsigned char</font> *pValue,<font color="#000080">   const char</font> *pTag,<font color="#000080">  int</font> nBit1to8,<font color="#000080">   const char</font> *pzCommaSeparated0Values, <font color="#000080">const char</font> *pzCommaSeparated1Values);
void MapMemberBit(<font color="#000080">unsigned short</font> *pValue,<font color="#000080">  const char</font> *pTag,<font color="#000080">  int</font> nBit1to16,<font color="#000080">  const char</font> *pzCommaSeparated0Values, <font color="#000080">const char </font>*pzCommaSeparated1Values);
void MapMemberBit(<font color="#000080">unsigned int</font> *pValue,<font color="#000080">    const char </font>*pTag,<font color="#000080">  int</font> nBit1to32,<font color="#000080">  const char </font>*pzCommaSeparated0Values, <font color="#000080">const char</font> *pzCommaSeparated1Values);
void MapMemberBit(<font color="#000080">unsigned __int64</font> *pValue,<font color="#000080">const char</font> *pTag,<font color="#000080">  int</font> nBit1to64,<font color="#000080">const char</font> *pzCommaSeparated0Values, <font color="#000080">const char</font> *pzCommaSeparated1Values);
</pre>
<p>The StartHere0.cpp example program contains this code:</p>
<pre lang="cs"><font color="#000080">class</font> MyCustomObject : <font color="#000080">public</font> XMLObject
{
  <font color="#000080">public</font>: <font color="#008000">// make public here for example simplicity - this is not required</font>

   <font color="#000080">unsigned char </font>m_bits; // 8 bits 
   <font color="#008000">// unsigned __int64 m_bits; // 64 bits = You can comment out the 8 bit line above and replace it with this one. No other code change is necessary.</font>

   <font color="#000080">virtual void</font> MapXMLTagsToMembers()
   {
	MapMemberBit( &amp;m_bits, &quot;Seven77thBit&quot;, 7, &quot;False,No,Off,0&quot;, 	&quot;True,Yes,On,1&quot;);
	MapMemberBit( &amp;m_bits, &quot;OnItsSide8&quot;, 8,   &quot;Black&quot;, 		&quot;White&quot;);
  }
   DECLARE_FACTORY(MyCustomObject, Thing) 

   MyCustomObject(){m_bits=0;}
   ~MyCustomObject(){};
};
IMPLEMENT_FACTORY(MyCustomObject, Thing)</pre>
<pre lang="cs"><font color="#008000">// This is the XML we&#39;ll process.</font>
<font color="#000080">char </font>pzXML[] = 
&quot;&lt;Thing&gt;&quot;
	&quot;&lt;Seven77thBit&gt;on&lt;/Seven77thBit&gt;&quot;
	&quot;&lt;OnItsSide8&gt;white&lt;/OnItsSide8&gt;&quot;
&lt;/Thing&gt;&quot;;
</pre>
<pre lang="cs">int main(int argc, char* argv[])
{
	MyCustomObject O;
	O.FromXMLX(pzXML);
<font color="#008000">
	// print out the value of each individual bit in m_bits
	// Change &quot;&lt;OnItsSide8&gt;&quot; from &quot;white&quot; to &quot;black&quot; in pzXML and watch how the bits change
	</font>for(int i=0;i&lt;8;i++)
	  printf(&quot;bit%d=%d\n&quot;,i+1,((O.m_bits&amp;(LONG_ONE&lt;&lt;i))!=0)); <font color="#008000">// :)</font>
<font color="#008000">	// this is the output
	// bit1=0
	// bit2=0
	// bit3=0
	// bit4=0
	// bit5=0
	// bit6=0
	// bit7=1
	// bit8=1</font></pre>
<pre lang="cs"><font color="#008000">
	// turn the 8th bit off - changes the value to &quot;Black&quot; in the XML - remove the following line and it stays &quot;White&quot; in the output XML
	</font>O.m_bits &amp;= ~(1&lt;&lt;7);	
<font color="#008000">	</font>printf(O.ToXML();<font color="#008000">

	// this is the output
	&lt;Thing&gt;
	    &lt;Seven77thBit&gt;True&lt;/Seven77thBit&gt;
	    &lt;OnItsSide8&gt;Black&lt;/OnItsSide8&gt;
	&lt;/Thing&gt;</font>
</pre>
<p>&nbsp;</p><h2><a name="Translating XML">Translating XML</a></h2>
<p>Translating values before the assignment of member variables from XML is a 
common need in the application layer.&nbsp; Also, the reverse that, translating 
the value stored in the member variable to the value that will appear in the 
XML.&nbsp;&nbsp; Without writing ANY code, we can Map() the translation logic 
with fine tuned control.&nbsp; This is done using the last 3 arguments of 
MapMember().&nbsp; Here is the comment taken from XMLObject.h explaining those 
last 3 arguments:&nbsp; </p>
<pre lang="cs"><font color="#008000">///////////////////////////////////////////////////////////////////////////////////////////////////////////
// Using Translation Maps (new in November 2013)
//////////////////////////////////////////////////////////////////-/////////////////////////////////////////
// pzTranslationMapIn translates values - for example this is how you might use it on a String:
// if pzTranslationMapIn = &quot;red*=Red,Mary Jane=Green,Grass=Green,XML_EMPTY_VALUE=Blue,XML_DEFAULT=Unknown
// ---------------------------------------------------------
// if &lt;pTag&gt; in the source xml starts with red - like &quot;redness&quot; or &quot;reddish&quot; it assigns member pValue = &quot;Red&quot;
// if &lt;pTag&gt; in the source xml is &quot;Mary Jane&quot; or &quot;Grass&quot; - it assigns member pValue = &quot;Green&quot;
// if &lt;pTag&gt;&lt;/pTag&gt; is empty in source xml - it assigns member pValue = &quot;Blue&quot;
// &lt;Tag&gt;&lt;/Tag&gt; will assign a mapped m_member = &quot;&quot;, unless XML_EMPTY_VALUE in pzTranslationMapIn overrides default behavior
// which will set m_strString2 == &quot;Blue&quot; due to XML_EMPTY_VALUE=Blue in pzTranslationMapIn.
//
// pzTranslationMapOut translates values in the XML to differ from what the member variable stores - for example:
// if pzTranslationMapOut = &quot;1=One,2=Two,777=Root,any*=anyTHING&quot;
// if pValue = &quot;1&quot; it will be seen as &quot;One&quot; in the XML.
// if pValue = &quot;2&quot; it will be seen as &quot;Two&quot; in the XML.
// if pValue = &quot;777&quot; it will be seen as &quot;Root&quot; in the XML.
// if pValue starts with &quot;any&quot; (like &quot;anyone&quot; or &quot;Anytime&quot; (all wildward searches are case insensitive)) it comes out as &quot;anyTHING&quot; in the XML.
//
// if XML_DEFAULT is specified and there is no known translation for the value, this value will be used.
// if XML_DEFAULT is not specified and there is no known translation for the value, the untranslated value will be used
// if XML_DEFAULT= is followed by a comma or null like this: &quot;A=1,B=2,XML_DEFAULT=,C=3&quot; or like this &quot;A=1,B=2,C=3,XML_DEFAULT=&quot;
// then the value with no known translation will NOT be used, and the value will be &quot;&quot; aka empty.
//
//
// .....and this is how you might use it on an Integer:
// pzTranslationMapIn = &quot;1=10,2=20,3=777,one=10,two=20,three=777,XML_EMPTY_VALUE=-777,XML_DEFAULT=0&quot;
// pzTranslationMapOut = &quot;10=ten,20=twenty,777=infinity,XML_DEFAULT=0&quot;
//
// 
// and the last argument, nTranslationFlags can be any combinations of these values:
// XLATE_CASE_INSENSITIVE_IN // When assigning variables from XML
// XLATE_CASE_INSENSITIVE_OUT // When writing XML translations
// XLATE_NO_IN_WILDCARDS // you never NEED to set this, as it is calculated and cached.
///////////////////////////////////////////////////////////////////////////////////////////////////////////
</font></pre>
<p>That may sound complex - but it&#39;s very easy to use.&nbsp; See the example 
program TranslatingXML.cpp where this (simple) code was taken from.</p>
<p>The <span style="background-color: #FFFF00">yellow string</span> affects how 
member variables are assigned a value.&nbsp; The
<span style="background-color: #008000">green string</span> affects how the XML 
is created.&nbsp; Each member variable has it&#39;s own translation rules.</p>
<p>Notice where the other colors are referenced in the places where they are 
used.</p>
<pre lang="cs">virtual void MapXMLTagsToMembers()
{
    MapMember( &amp;m_strString2, &quot;String2&quot;, <span style="background-color: #FFFF00">&quot;red*=Red,Mary Jane=Green,grass=Green&quot;</span>,  <span style="background-color: #008000">&quot;1=One,2=Two,777=Root,any*=anyVALUE&quot;</span>);
    MapMember( &amp;m_strString3, &quot;String3&quot;, &quot;red*=Red,Mary Jane=Green,grass=Green&quot;,  &quot;1=One,2=Two,777=Root,any*=anyVALUE&quot;);
    MapMember( &amp;m_strString4, &quot;String4&quot;, &quot;red*=Red,Mary Jane=Green,grass=Green&quot;,  &quot;1=One,2=Two,777=Root,any*=anyVALUE&quot;<span style="background-color: #808000">,XLATE_CASE_INSENSITIVE_IN);</span>
    MapMember( &amp;m_strString5, &quot;String5&quot;, &quot;red*=Red,Mary Jane=Green,grass=Green&quot;,  &quot;1=One,2=Two,777=Root,any*=anyVALUE&quot;<span style="background-color: #808000">	</span><span style="background-color: #FF0000">	</span><span style="background-color: #808000">	       );</span>
    MapMember( &amp;m_strString6, &quot;String6&quot;, &quot;red*=Red,Mary Jane=Green,grass=Green&quot;,  &quot;1=One,2=Two,777=Root,any*=anyVALUE&quot;);
    MapMember( &amp;m_strString7, &quot;String7&quot;, &quot;red*=Red,Mary Jane=Green,grass=Green&quot;,  &quot;XMLFoundation=best,any*=anyVALUE&quot;,XLATE_CASE_INSENSITIVE_OUT | XLATE_CASE_INSENSITIVE_IN);
    MapMember( &amp;m_strString8, &quot;String8&quot;, <span style="background-color: #FFFF00">&quot;red*=Red,Mary Jane=Green,grass=Green</span><span style="background-color: #0F55FF">,XML_EMPTY_VALUE=Blue&quot;</span>, <span style="background-color: #008000">&quot;XMLFoundation=best,any*=anyVALUE&quot;</span>);
    MapMember( &amp;m_strString9, &quot;String9&quot;, &quot;red*=Red,Mary Jane=Green,grass=Green,XML_EMPTY_VALUE=Blue&quot;, &quot;1=One,2=Two,777=Root,any*=anyVALUE,XML_DEFAULT=xxxxxx&quot;);
    MapMember( &amp;m_strString10, &quot;String10&quot;,&quot;red*=Red,Mary Jane=Green,grass=Green, &quot;, &quot;1=One,2=Two,777=Root,any*=anyVALUE,XML_EMPTY_VALUE=zzzzzzz&quot;);
    MapMember( &amp;m_strString11, &quot;String11&quot;,&quot;red*=Red,Mary Jane=Green,grass=Green<span style="background-color: #800080">,XML_DEFAULT=We Know </span>&quot;, &quot;1=One,2=Two,777=Root,any*=anyVALUE&quot;);
    MapMember( &amp;m_strString12, &quot;String12&quot;,&quot;red*=Red,Mary Jane=Green,grass=Green,XML_DEFAULT=We Know,XML_EMPTY_VALUE=Blue&quot;, &quot;1=One,2=Two,777=Root,any*=anyVALUE&quot;);

    <font color="#008000">// this one MapMember handles all string in the string list</font>
    MapMember( &amp;m_strList, &quot;StringList&quot;, <span style="background-color: #FFFF00">&quot;Wrapper&quot;, &quot;red*=Red,Mary Jane=Green,grass=Green,XML_EMPTY_VALUE=Blue&quot;</span>, <span style="background-color: #008000">&quot;Green=G.G.G.Green,Red=Bloody Red,777=Root,pur*=Purp&quot;</span>);

}


<font color="#008000">//
// This is the XML we&#39;ll process.
//
</font>char pzXML[] = 
&quot;&lt;Thing&gt;&quot;
    &quot;&lt;String2&gt;redness&lt;/String2&gt;&quot; <font color="#008000">  // sets m_strString2 == &quot;Red&quot; from the </font><span style="background-color: #FFFF00">red*</span><font color="#008000"> wildcard match
</font>    &quot;&lt;String3&gt;reddish&lt;/String3&gt;&quot; <font color="#008000">  // sets m_strString3 == &quot;Red&quot; from the </font><span style="background-color: #FFFF00">red*</span><font color="#008000"> wildcard match
</font>    &quot;&lt;String4&gt;Mary jane&lt;/String4&gt;&quot; <font color="#008000">// sets m_strString4 == &quot;Green&quot; </font><span style="background-color: #808000">(with XLATE_CASE_INSENSITIVE_IN </span><font color="#008000">in the last argument to MapMember of m_strString4 )</font>
    &quot;&lt;String5&gt;Mary jane&lt;/String5&gt;&quot; <font color="#008000">// sets m_strString5 == &quot;Mary jane&quot; </font><span style="background-color: #808000">(</span><span style="background-color: #FF0000">without</span><span style="background-color: #808000"> XLATE_CASE_INSENSITIVE_IN</span><font color="#008000"> in the last argument to MapMember of m_strString2 )</font>
    &quot;&lt;String6&gt;Mary Jane&lt;/String6&gt;&quot; <font color="#008000">// sets m_strString6 == &quot;Green&quot; - notice the uppercase &#39;J&#39;</font>
    &quot;&lt;String7&gt;grAss&lt;/String7&gt;&quot;<font color="#008000">     // sets m_strString7 == &quot;Green&quot;</font>

    // empty vs null
    &quot;&lt;String8&gt;&lt;/String8&gt;&quot;<font color="#008000"> 		   // sets m_strString8 == &quot;Blue&quot;<span style="background-color: #0F55FF"> </span></font><span style="background-color: #0F55FF">due to XML_EMPTY_VALUE=Blue</span>
    <font color="#008000">// &quot;&lt;String9&gt;&lt;/String9&gt;&quot; 	   // leaves m_strString9 to its constructor initted default == &quot;MyNullValue&quot;
</font>    &quot;&lt;String10&gt;&lt;/String10&gt;&quot; <font color="#008000">	   // sets m_strString10 == &quot;&quot; because XML_EMPTY_VALUE= is not present</font>
    &quot;&lt;String11&gt;unknown value&lt;/String11&gt;&quot;<font color="#008000">// sets m_strString11 == <span style="background-color: #800080">&quot;We know &quot; due to XML_DEFAULT=We know</span></font>
    &quot;&lt;String12&gt;&lt;/String12&gt;&quot; <font color="#008000">	   // sets m_strString12 == &quot;Blue&quot; because XML_EMPTY_VALUE has precedence over XML_DEFAULT</font>

    <font color="#008000">// all strings in the string list are handled by one MapMember(&amp;m_strList)</font>
       &quot;&lt;Wrapper&gt;&quot; 			<span style="background-color: #FFFF00"><font color="#008000">// </font>VALUE IN MEMBER<font color="#008000"> </font></span><font color="#008000">	</font><span style="background-color: #008000">VALUE IN OUTPUT XML
</span>	&quot;&lt;StringList&gt;redness&lt;/StringList&gt;&quot;  	    <font color="#008000">// </font><span style="background-color: #FFFF00">Red</span><font color="#008000"> 		 </font>  <span style="background-color: #008000">Bloody Red</span>
	&quot;&lt;StringList&gt;reddish&lt;/StringList&gt;&quot;  	   <font color="#008000"> //</font> <span style="background-color: #FFFF00">Red</span><font color="#008000"> 		  </font> <span style="background-color: #008000">Bloody Red</span>
	&quot;&lt;StringList&gt;Grass&lt;/StringList&gt;&quot; 	    <font color="#008000">// </font><span style="background-color: #FFFF00">Grass</span><font color="#008000"> 		  </font> <span style="background-color: #008000">Grass</span>
	&quot;&lt;StringList&gt;grass&lt;/StringList&gt;&quot; 	    <font color="#008000">// </font><span style="background-color: #FFFF00">Green</span><font color="#008000"> 		   </font><span style="background-color: #008000">G.G.G.Green</span>
	&quot;&lt;StringList&gt;purple&lt;/StringList&gt;&quot; 	    <font color="#008000">// </font><span style="background-color: #FFFF00">purple</span><font color="#008000"><span style="background-color: #FFFF00"> </span>		  </font> <span style="background-color: #008000">Purp</span> 
	&quot;&lt;StringList&gt;&lt;/StringList&gt;&quot; 	    <font color="#008000">// </font><span style="background-color: #FFFF00">Blue</span> <font color="#008000">		   </font><span style="background-color: #008000">Blue</span>
    &quot;&lt;/Wrapper&gt;&quot;
&lt;/Thing&gt;&quot;;
<font color="#008000"><br></font><br>&nbsp;</pre>
<pre lang="cs">int main(int argc, char* argv[])
{
    MyCustomObject O;
    O.FromXMLX(pzXML); <font color="#008000">// see that our Object&#39;s member values have been translated as commented above after this line of code.	</font>
<br>    // now we will assign some members.
    O.m_strString2 = &quot;1&quot;; 		<font color="#008000">// this will translate to &quot;One&quot; the XML</font>
    O.m_strString3 = &quot;2&quot;; 		<font color="#008000">// this will translate to &quot;Two&quot; the XML</font>
    O.m_strString4 = &quot;777&quot;; 	<font color="#008000">// this will translate to &quot;Root&quot; the XML</font>
    O.m_strString5 = &quot;anybody&quot;; 	<font color="#008000">// this will translate to &quot;anyVALUE&quot; the XML</font>
    O.m_strString6 = &quot;anything&quot;; 	<font color="#008000">// this will translate to &quot;anyVALUE&quot; the XML</font>
    O.m_strString7 = &quot;XMLFoundation&quot;;<font color="#008000">// this will translate to &quot;best&quot; the XML</font>
    O.m_strString8 = &quot;xmlFoundation&quot;;<font color="#008000">// this will translate to &quot;xmlFoundation&quot; the XML</font>
    O.m_strString9 = &quot;&quot;; 		<font color="#008000">// default - this will translate to &quot;xxxxxx&quot; the XML</font>
    O.m_strString10 = &quot;&quot;; 		<font color="#008000">// empty - outputs an empty string in the XML: &lt;String10/&gt;</font>
 
    printf(O.ToXMLX());  <font color="#008000">// see that everything was translated as we expected</font>

}<br>&nbsp;</pre>
<p>&nbsp;</p>
<p>&nbsp;</p><h2><a name="XMLFoundation for Java">XMLFoundation for Java</a></h2><p>XMLFoundation
 supports Java too, it supports all Java data types like (string byte 
bool double long short) as well as Java data structures 
such as (Vector Stack ArrayList LinkedList TreeSet HashSet ).  The 
XMLFoundation for Java is binary.  If you want to build it yourself, 
you can because the source code to the entire JavaXMLFoundation is 
public and included in this release. 
There is no need to build it, but it's nice to be able to.  I can hear 
some uneducated Java programmer already saying "I only want a 'Pure' 
Java 
solution".  This is Pure.  It's as pure as the JVM, because if you look 
close you'll see that it is actually an enhancement to the JVM.</p><p>The
 JVM (Java Virtual Machine) is written in C and C++.  Your Java code 
runs anywhere the JVM can compile, and the 
XMLFoundation works the same way.  The good news is that Java 
programmers don't have to deal with C++ just because their JVM is 
written in C++. 
The same is true of the XMLFoundation for Java.</p><p>The XMLFoundation 
uses JNI (Java Native Interface). It parses the XML in the native binary
 (that was created by a C++ compiler just 
like the JVM) and instantiates 'pure' Java Objects through JNI, then it 
assigns all the member variables just like the C++ XMLFoundation does.  
Can you 
think of a faster way to get the job done?</p><p>This is some sample code that uses the JavaXMLFoundation. A much more detailed example is included in the source code:</p><pre lang="C++">// Java source code that shows how to use the XMLFoundation using
// inheritance or containment. It is nearly identical to C++

import java.util.Iterator;
import java.util.Vector;


// MyLineItem has an "ObjectId", that is a value created from
// members and/or attributes of this object that uniquely identify
// it among all instances of it's own type. "ObjectId"'s are
// optional but allow you to perform complex "object updates"
// easily through XML. In main() below, this functionality is// used when getXML2() is applied. ObjectId's are like a database
// primary key in that they are generally not modified.
class MyLineItem extends XMLObject
{
     private String item;
     private String quantity;
     private int ItemID;
     MyLineItem()
     {
          // call the base class constructor with the XML-tag for 'this'
          super("LineItem");
     };    }
     MyLineItem(int nID, String itm, String qty)
     {
          super("LineItem");
          item = itm;
          quantity = qty;
          ItemID = nID;
     }

     void MapXMLTagsToMembers()
     {
          //         member      member         xml-tag           (optional)wrapper
          //-----------------------------------------------------------------
          MapMember(quantity,     "quantity",    "Quantity");
          MapMember(item,         "item",        "Description");
          MapMember(ItemID,       "ItemID",      "SKU");

          //////////////////////////////////////////////////////////////////
          // MapObjectId() is optional.
          //////////////////////////////////////////////////////////////////
          MapObjectId(this, "ItemID"); // takes 1 to 5 mapped 'Key parts'
     }
}


// Not "derived from" but "contains" XML support.
class Customer2
{
     public String          name;
     private int            CustID;
     private XMLObject      ContainedXMLObj;
     public MyOrder         objOrder;
     private Vector         vecStrings;

     long l;
     short s;
     double d;
     byte b;
     boolean z;


     public void XMLDump()
     {
          MyExchange("out");
          System.err.println( ContainedXMLObj.toXML() );
     }

     // indirect inheritance manages calls to FromXML() and ToXML()
     // manually, exposing them is optional. Member&lt;--&gt;XML exchange is
     // also done manually, generally following calls to FromXML() or ToXML()
     // this affords the developer full control for atypical implementations.
     void MyExchange(String inOut)
     {
          ContainedXMLObj.Member(this, inOut, b,     "b","byte","", 1);
          ContainedXMLObj.Member(this, inOut, z,     "z","bool","", 1);
          ContainedXMLObj.Member(this, inOut, l,     "l","long","", 1);
          ContainedXMLObj.Member(this, inOut, d,     "d","double","", 1);
          ContainedXMLObj.Member(this, inOut, s,     "s","short","", 1);
          sp;   "s","short","", 1);
          ContainedXMLObj.Member(this, inOut, name,     "name","FirstName","", 1);
          ContainedXMLObj.Member(this, inOut, CustID,     "CustID","CustomerID","", 1);
          ContainedXMLObj.Member(this, inOut, objOrder,     "objOrder",     "Order","MyOrder","");
          ContainedXMLObj.Member(this, inOut, vecStrings,"vecStrings",
              "StringItem","String",  "StringList Level2Wrapper");
     }

     public Customer2( String strXML )
     {
          // create a new 'empty' object that maps to "Customer".
          ContainedXMLObj = new XMLObject("Customer", false );
          ContainedXMLObj.fromXML(strXML);
          MyExchange("in");
     }
   
     // FromXML is not inheriterd, so we can expose the functionality through a
     // controlled accessor.
     public void ApplyXML( String strXML )
     {
          ContainedXMLObj.fromXML(strXML);
          MyExchange("in");
     }
}
// End of sample Java source code</pre><p>This is some of the code I 
developed inside the JavaXMLFoundation that interacts with the JVM.  
(Don't worry you'll never have to work with this code.)</p><pre lang="C++">jobject MakeObjectInstance(JNIEnv *env,const char *pzObjectType,
                                 DynamicXMLObject *pDO,DynamicXMLObject *pDXOOOwner)
{
     if (env-&gt;ExceptionOccurred())
     {
          env-&gt;ExceptionClear();
     }

     jclass clazzA = env-&gt;FindClass(pzObjectType);
     jobject objReturnValue = 0;
     GString strType("Ljava/lang/String;");

     // if this class type exposes a 'ctor that takes a single XMLObject
     // we are using containment.
     jmethodID midctor = env-&gt;GetMethodID(clazzA, "", "(LXMLObject;)V");
     if (env-&gt;ExceptionOccurred())
     {
          env-&gt;ExceptionClear();
     }
     if (midctor)
     {
          // create a new java XMLObject instance
          jclass clazzX = env-&gt;FindClass("XMLObject");
          jmethodID midX =
                    env-&gt;GetMethodID(clazzX, "", "(Ljava/lang/String;)V");
          jstring     tagX = env-&gt;NewStringUTF(pDO-&gt;GetObjectTag());
          jobject objX = env-&gt;NewObject(clazzA, midX, tagX );

          // assign the object handle into the instance just created. bject handle into the instance just created.
          jclass clazz = env-&gt;GetObjectClass(objX);
          jfieldID fid = env-&gt;GetFieldID(clazz, "oH", "I");
          env-&gt;SetIntField(objX, fid, CastDXMLO(pDO));

          // create a new instance of some user defined java class that is
          // not extending XMLObject. Pass the XMLObject to the 'ctor.
          objReturnValue = env-&gt;NewObject(clazzA, midctor, objX );
     }
     else
     {
          // create an instance of a java object derived from the java XMLObject
          objReturnValue = env-&gt;AllocObject(clazzA);

          // assign the base class object handle directly.
          jclass clazz = env-&gt;GetObjectClass(objReturnValue);

          // any object that extends XMLObject will have the oH (Object Handle)
          // If the Object created is a String the fid will be 0.
          jfieldID fid = env-&gt;GetFieldID(clazz, "oH", "I");
          if (env-&gt;ExceptionOccurred())
          {
               env-&gt;ExceptionClear();
          }
          if (fid)
          {
               env-&gt;SetIntField(objReturnValue, fid, CastDXMLO(pDO));

               // create the jobject to DXO index
               union CAST_THIS_TYPE_SAFE_COMPILERS
               {
                    jobject   mbrObj;
                    void *    mbrVoid;
               }Member;

               Member.mbrObj = env-&gt;NewGlobalRef(objReturnValue);
               pDXOOOwner-&gt;addSubUserLanguageObject(Member.mbrVoid);
               // printf("===NewGlobRef[%d]\n",Member.mbrObj);
               pDO-&gt;setUserLanguageObject(Member.mbrVoid);
               cacheManager.addAlternate( pDO );
          }
          else if (strType.CompareNoCase(pzObjectType) != 0)
          {
            GString Err;
            Err.Format("Object type [%s] must either be derived from XMLObject\n"
            "or supply a constructor %s(XMLObject o)",pzObjectType,pzObjectType);
          }
     }
     pDO-&gt;SetObjectType(pzObjectType);
     return objReturnValue;
}</pre><p>Java programmers will derive from this class - then the use is nearly identical to the C++ XMLFoundation:</p><pre lang="C++">import java.util.Vector;
import java.util.Stack;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.TreeSet;
import java.util.HashSet;

public class XMLObject {
     static { System.loadLibrary("JavaXMLFoundation");    }
     private static int InstanceId = 0;

     private native void JavaMap(int oH, int DataType,String strName,String xmlTag,
         String strWrapper, String ObjType, String strContainerType, int nSource);
     private native void JavaExchange(Object o, int oH, String inout,int nType,
         String b,String c,String d,String strObjectType, String strContainerType,
         int nSource);
     private native int  JavaConstruct(int n, String strXMLTag, int bAutoDataSync);
     private native void JavaDestruct(int oH);
     private native void JavaMapCacheDisable(int oH);
     private native void JavaMapOID(int oH, Object o, String Key1, String Key2,
         String Key3, String Key4, String Key5);
     private native XMLObject JavaGetSubObj(int oH);
     private native void JavaFromXML(int oH, String strXML);
     private native String JavaToXML(int oH);
     private native void JavaRemoveAll(int oH);

     private int          oH; // XML-Object Handle


     public void MemberRemoveAll()
     {
          JavaRemoveAll(oH);
     }

     protected void finalize()
     {
          JavaDestruct(oH);
     }
     protected void freedom()
     {
          JavaDestruct(oH);
     }

     public XMLObject(String strXMLTag)
     {
          oH = ++InstanceId;
          oH = JavaConstruct(oH, strXMLTag, 1);
     }
     public XMLObject(String strXMLTag, boolean bAutoDataSync)
     {
          oH = ++InstanceId;
          if (bAutoDataSync)
               oH = JavaConstruct(oH, strXMLTag, 1);
          else
               oH = JavaConstruct(oH, strXMLTag, 0);
     }

     // Override this 'virtual' method to map member to XML tags
     // through calls to MapMember();
     private void MapXMLTagsToMembers()
     {
     }
     void DontCacheMemberMaps()
     {
          JavaMapCacheDisable(oH);
     }
     void fromXML(String strXML)
     {
          JavaFromXML(oH, strXML);
     }
     String toXML()
     {
          return JavaToXML(oH);
     }


     private String MakeObjectName(String strIn)
     {
          if (strIn.compareToIgnoreCase("String") == 0)
          {
               strIn = "Ljava/lang/String;";
          };        }
          else
          {
               String sTemp = "L" + strIn + ";";
               strIn = sTemp;
          }
          return strIn;
     }


     //
     //    MapAttrib for each native data type (1st without the optional 'nested' argument)
     //  
     public void MapAttrib(long z, String pzName, String pzXMLTag)
     {
          JavaMap(oH,0,pzName,pzXMLTag,"","", "", 2);
     }
     public void MapAttrib(double z, String pzName, String pzXMLTag )
     {
          JavaMap(oH,1,pzName,pzXMLTag,"","", "", 2);
     }
     public void MapAttrib(short z, String pzName, String pzXMLTag )
     {
          JavaMap(oH,2,pzName,pzXMLTag,"","", "", 2);
     }
     public void MapAttrib(byte z, String pzName, String pzXMLTag)
     {
          JavaMap(oH,3,pzName,pzXMLTag,"","", "", 2);
     }
     public void MapAttrib(String z, String pzName, String pzXMLTag)
     {
          JavaMap(oH,4,pzName,pzXMLTag,"","", "", 2);
     }
     public void MapAttrib(int z, String pzName, String pzXMLTag )
     {
          JavaMap(oH,5,pzName,pzXMLTag,"","", "", 2);
     }
     public void MapAttrib(boolean z, String pzName, String pzXMLTag )
     {
          JavaMap(oH,6,pzName,pzXMLTag,"","", "", 2);
     }

     //
     //    MapAttrib for each native data type (now with the optional 'nested' argument)
     //  
     public void MapAttrib(long z, String pzName, String pzXMLTag, String pzNestedInTag)
     {
          JavaMap(oH,0,pzName,pzXMLTag,pzNestedInTag,"", "", 2);
     }
     public void MapAttrib(double z, String pzName, String pzXMLTag, String pzNestedInTag )
     {
          JavaMap(oH,1,pzName,pzXMLTag,pzNestedInTag,"", "", 2);
     }
     public void MapAttrib(short z, String pzName, String pzXMLTag, String pzNestedInTag )
     {
          JavaMap(oH,2,pzName,pzXMLTag,pzNestedInTag,"", "", 2);
     }
     public void MapAttrib(byte z, String pzName, String pzXMLTag, String pzNestedInTag)
     {
          JavaMap(oH,3,pzName,pzXMLTag,pzNestedInTag,"", "", 2);
     }
     public void MapAttrib(String z, String pzName, String pzXMLTag, String pzNestedInTag )
     {
          JavaMap(oH,4,pzName,pzXMLTag,pzNestedInTag,"", "", 2);
     }
     public void MapAttrib(int z, String pzName, String pzXMLTag, String pzNestedInTag )
     {
          JavaMap(oH,5,pzName,pzXMLTag,pzNestedInTag,"", "", 2);
     }
     public void MapAttrib(boolean z, String pzName, String pzXMLTag, String pzNestedInTag )
     {
          JavaMap(oH,6,pzName,pzXMLTag,pzNestedInTag,"", "", 2);
     }

   
     //
     //    MapMember for each native data type (1st without optional nested-in-tag)
     //  
     public void MapMember(long z, String pzName, String pzXMLTag)
     {
          JavaMap(oH,0,pzName,pzXMLTag,"","", "", 1);
     }
     public void MapMember(double z, String pzName, String pzXMLTag )
     {
          JavaMap(oH,1,pzName,pzXMLTag,"","", "", 1);
     }
     public void MapMember(short z, String pzName, String pzXMLTag )
     {
          JavaMap(oH,2,pzName,pzXMLTag,"","", "", 1);
     }
     public void MapMember(byte z, String pzName, String pzXMLTag)
     {
          JavaMap(oH,3,pzName,pzXMLTag,"","", "", 1);
     }
     public void MapMember(String z, String pzName, String pzXMLTag )
     {
          JavaMap(oH,4,pzName,pzXMLTag,"","", "", 1);
     }
     public void MapMember(int z, String pzName, String pzXMLTag )
     {
          JavaMap(oH,5,pzName,pzXMLTag,"","", "", 1);
     }
     public void MapMember(boolean z, String pzName, String pzXMLTag )
     {
          JavaMap(oH,6,pzName,pzXMLTag,"","", "", 1);
     }
     public void MapMember(Object ob, String pzName, String pzXMLTag, String strObjectType )
     {
          JavaMap(oH,7,pzName,pzXMLTag,"",MakeObjectName(strObjectType), "", 1);
     }
     public void MapMember(Vector a, String pzName, String pzXMLTag, String strObjectType )
     {
          JavaMap(oH,8,pzName,pzXMLTag,"",MakeObjectName(strObjectType),"Ljava/util/Vector;", 1);
     }
     public void MapMember(Stack a, String pzName, String pzXMLTag, String strObjectType )
     {
          JavaMap(oH,8,pzName,pzXMLTag,"",MakeObjectName(strObjectType),"Ljava/util/Stack;", 1);
     }
     public void MapMember(ArrayList a, String pzName, String pzXMLTag, String strObjectType )
     {
          JavaMap(oH,8,pzName,pzXMLTag,"",MakeObjectName(strObjectType),"Ljava/util/ArrayList;", 1);
     }
     public void MapMember(LinkedList a, String pzName, String pzXMLTag, String strObjectType )
     {
          JavaMap(oH,8,pzName,pzXMLTag,"",MakeObjectName(strObjectType),"Ljava/util/LinkedList;", 1);
     }
     public void MapMember(TreeSet a, String pzName, String pzXMLTag, String strObjectType )
     {
          JavaMap(oH,8,pzName,pzXMLTag,"",MakeObjectName(strObjectType),"Ljava/util/TreeSet;", 1);
     }
     public void MapMember(HashSet a, String pzName, String pzXMLTag, String strObjectType )
     {
          JavaMap(oH,8,pzName,pzXMLTag,"",MakeObjectName(strObjectType),"Ljava/util/HashSet;", 1);
     }

     //
     //    MapMember for each native data type (now with optional nested-in-tag)
     //  
     public void MapMember(long z, String pzName, String pzXMLTag, String pzNestedInTag)
     {
          JavaMap(oH,0,pzName,pzXMLTag,pzNestedInTag,"", "", 1);
     }
     public void MapMember(double z, String pzName, String pzXMLTag, String pzNestedInTag )
     {
          JavaMap(oH,1,pzName,pzXMLTag,pzNestedInTag,"", "", 1);
     }
     public void MapMember(short z, String pzName, String pzXMLTag, String pzNestedInTag )
     {
          JavaMap(oH,2,pzName,pzXMLTag,pzNestedInTag,"", "", 1);
     }
     public void MapMember(byte z, String pzName, String pzXMLTag, String pzNestedInTag)
     {
          JavaMap(oH,3,pzName,pzXMLTag,pzNestedInTag,"", "", 1);
     }
     public void MapMember(String z, String pzName, String pzXMLTag, String pzNestedInTag )
     {
          JavaMap(oH,4,pzName,pzXMLTag,pzNestedInTag,"", "", 1);
     }
     public void MapMember(int z, String pzName, String pzXMLTag, String pzNestedInTag )
     {
          JavaMap(oH,5,pzName,pzXMLTag,pzNestedInTag,"", "", 1);
     }
     public void MapMember(boolean z, String pzName, String pzXMLTag, String pzNestedInTag )
     {
          JavaMap(oH,6,pzName,pzXMLTag,pzNestedInTag,"", "", 1);
     }
     public void MapMember(Object ob, String pzName, String pzXMLTag,
         String strObjectType, String pzNestedInTag )
     {
          JavaMap(oH,7,pzName,pzXMLTag,pzNestedInTag,MakeObjectName(strObjectType), "", 1);
     }
     public void MapMember(Vector a, String pzName, String pzXMLTag,
         String strObjectType, String pzNestedInTag )
     {
          JavaMap(oH,8,pzName,pzXMLTag,pzNestedInTag,MakeObjectName(strObjectType),
              "Ljava/util/Vector;", 1);
     }
     public void MapMember(Stack a, String pzName, String pzXMLTag,
          String strObjectType, String pzNestedInTag )
     {
          JavaMap(oH,8,pzName,pzXMLTag,pzNestedInTag,MakeObjectName(strObjectType),
              "Ljava/util/Stack;", 1);
     }
     public void MapMember(ArrayList a, String pzName, String pzXMLTag,
          String strObjectType, String pzNestedInTag )
     {
          JavaMap(oH,8,pzName,pzXMLTag,pzNestedInTag,MakeObjectName(strObjectType),
              "Ljava/util/ArrayList;", 1);
     }
     public void MapMember(LinkedList a, String pzName, String pzXMLTag,
          String strObjectType, String pzNestedInTag )
     {
          JavaMap(oH,8,pzName,pzXMLTag,pzNestedInTag,MakeObjectName(strObjectType),
              "Ljava/util/LinkedList;", 1);
     }
     public void MapMember(TreeSet a, String pzName, String pzXMLTag,
          String strObjectType, String pzNestedInTag )
     {
          JavaMap(oH,8,pzName,pzXMLTag,pzNestedInTag,MakeObjectName(strObjectType),
              "Ljava/util/TreeSet;", 1);
     }
     public void MapMember(HashSet a, String pzName, String pzXMLTag,
          String strObjectType, String pzNestedInTag )
     {
          JavaMap(oH,8,pzName,pzXMLTag,pzNestedInTag,MakeObjectName(strObjectType),
              "Ljava/util/HashSet;", 1);
     }

     //
     //    Map ObjectID's - the JavaXMLFoundation works just the same with respect
     // to object caching
     //  
    public void MapObjectId(Object o, String Key1)
     {
          JavaMapOID(oH, o, Key1, "", "", "", "");
     }
     public void MapObjectId(Object o, String Key1, String Key2)
     {
          JavaMapOID(oH, o, Key1, Key2, "", "", "");
     }
     public void MapObjectId(Object o, String Key1, String Key2, String Key3)
     {
          JavaMapOID(oH, o, Key1, Key2, Key3, "", "");
     }
     public void MapObjectId(Object o, String Key1, String Key2, String Key3, String Key4)
     {
          JavaMapOID(oH, o, Key1, Key2, Key3, Key4, "");
     }
     public void MapObjectId(Object o, String Key1, String Key2, String Key3,
          String Key4, String Key5)
     {
          JavaMapOID(oH, o, Key1, Key2, Key3, Key4, Key5);
     }


     //
     //    Get/Set Member for each native data type
     //  
     public void Member(Object o, String xfer, long z, String pzName, String pzXMLTag,
          String pzNestedInTag, int nSource )
     {
          JavaExchange(o,oH,xfer,0,pzName,pzXMLTag,pzNestedInTag,"","", nSource);
     }
     public void Member(Object o, String xfer, double z, String pzName, String pzXMLTag,
         String pzNestedInTag, int nSource )
     {
          JavaExchange(o,oH,xfer,1,pzName,pzXMLTag,pzNestedInTag,"","",nSource);
     }
     public void Member(Object o, String xfer, short z, String pzName, String pzXMLTag,
          String pzNestedInTag, int nSource)
     {
          JavaExchange(o,oH,xfer,2,pzName,pzXMLTag,pzNestedInTag,"","",nSource);
     }
     public void Member(Object o, String xfer, byte z, String pzName, String pzXMLTag,
          String pzNestedInTag, int nSource )
     {
          JavaExchange(o,oH,xfer,3,pzName,pzXMLTag,pzNestedInTag,"","",nSource);
     }
     public void Member(Object o, String xfer, String z, String pzName, String pzXMLTag,
          String pzNestedInTag , int nSource)
     {
          JavaExchange(o,oH,xfer,4,pzName,pzXMLTag,pzNestedInTag,"","",nSource);
     }
     public void Member(Object o, String xfer, int z, String pzName, String pzXMLTag,
          String pzNestedInTag, int nSource )
     {
          JavaExchange(o,oH,xfer,5,pzName,pzXMLTag,pzNestedInTag,"","",nSource);
     }
     public void Member(Object o, String xfer, boolean z, String pzName,
          String pzXMLTag, String pzNestedInTag, int nSource )
     {
          JavaExchange(o,oH,xfer,6,pzName,pzXMLTag,pzNestedInTag,"","",nSource);
     }
     public void Member(Object o, String xfer, Object o2, String pzName,
          String pzXMLTag, String pzObjectType, String pzNestedInTag )
     {
          JavaExchange(o,oH,xfer,7,pzName,pzXMLTag,pzNestedInTag,
              MakeObjectName(pzObjectType),"",1);
     }
     public void Member(Object o, String xfer, Vector a, String pzName,
          String pzXMLTag, String strObjectType, String pzNestedInTag )
     {
          JavaExchange(o,oH,xfer,8,pzName,pzXMLTag,pzNestedInTag,
              MakeObjectName(strObjectType),"Ljava/util/Vector;",1);
     }
     public void Member(Object o, String xfer, Stack a, String pzName,
          String pzXMLTag, String strObjectType, String pzNestedInTag)
     {
          JavaExchange(o,oH,xfer,8,pzName,pzXMLTag,pzNestedInTag,
              MakeObjectName(strObjectType),"Ljava/util/Stack;",1);
     }
     public void Member(Object o, String xfer, ArrayList a, String pzName,
          String pzXMLTag, String strObjectType, String pzNestedInTag )
     {
          JavaExchange(o,oH,xfer,8,pzName,pzXMLTag,pzNestedInTag,
              MakeObjectName(strObjectType),"Ljava/util/ArrayList;",1);
     }
     public void Member(Object o, String xfer, LinkedList a,
          String pzName, String pzXMLTag, String strObjectType,
          String pzNestedInTag )
     {
          JavaExchange(o,oH,xfer,8,pzName,pzXMLTag,pzNestedInTag,
              MakeObjectName(strObjectType),"Ljava/util/LinkedList;",1);
     }
     public void Member(Object o, String xfer, TreeSet a, String pzName,
          String pzXMLTag, String strObjectType, String pzNestedInTag )
     {
          JavaExchange(o,oH,xfer,8,pzName,pzXMLTag,pzNestedInTag,
              MakeObjectName(strObjectType),"Ljava/util/TreeSet;",1);
     }
     public void Member(Object o, String xfer, HashSet a,
          String pzName, String pzXMLTag, String strObjectType, String pzNestedInTag )
     {
          JavaExchange(o,oH,xfer,8,pzName,pzXMLTag,pzNestedInTag,
              MakeObjectName(strObjectType),"Ljava/util/HashSet;",1);
     }
}</pre>
<h2><a name="About the author(s) of XMLFoundation">About the author(s) of XMLFoundation</a></h2><p>The XMLFoundation was designed and developed mostly by <a href="http://cid-d7ec275e76d295cf.skydrive.live.com/self.aspx/Business/Resume%20of%20Brian%20Aberle.doc">myself</a>,
 
however I had help from co-designers on the NCIS (National Clinical 
Information System) Project, and mostly only 1 other co-developer.  
Special thanks to the SAIC management who 
believed in me and gave me the opportunity to develop the mother 
product. Thanks to everyone who stood beside me during the long and 
expensive labor of 
putting this work together.  "I told you so" to everyone else.  In the 
end technology prevails over politics and ignorance.  The XMLFoundation 
contains 
several independent algorithms that were developed by other authors - 
and their supporting communities - their source code contains more 
information about 
them.   Historically it has been the solo engineers that set the 
direction for the masses.  Bjarne Stroustrup incremented the work of 
Brian Kernighan and  Dennis Ritchie.  There are countless contributors 
from the purest perspective of technology advancement and they could not
 
possibly all be named here.</p><h2><a name="Conclusion">Conclusion</a></h2><p>In
 conclusion, this started a long time ago and it's not going away 
anytime soon.  It's a masterpiece conspiracy to end times of high 
crimes.</p>
</span>
<!-- End Article -->




</div> 


</body></html>